<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[机器学习术语]]></title>
    <url>%2FML-introduce.html</url>
    <content type="text"><![CDATA[机器学习术语 机器学习正是这样一门学科，它致力于研究如何通过计算的手段，利用经验来改善系统自身的性能.在计算机系统中，“经验”通常以“数据”形式存在，因此，机器学习所研究的主要内容，是关于在计算机上从数据中产生“模 型”（model)的算法，即“学习算法”（learning algorithm).有了学习算法，我们把经验数据提供给它，它就能基于这些数据产生模型；在面对新的情况时(例 如看到一个没剖开的西瓜)，模型会给我们提供相应的判断(例如好瓜).如果说计算机科学是研究关于“算法”的学问，那么类似的，可以说机器学习是研究关于“学习算法”的学问。 基本术语 编号 色泽 根蒂 敲声 好瓜 1 青绿 蜷缩 浊响 是 2 乌黑 蜷缩 浊响 是 3 青绿 硬挺 清脆 否 4 乌黑 稍蜷 沉闷 否 数据集（data set） 这组记录的集合称为一个数据集（data set） 示例”（instance)、样 本”（sample) 其中每条记录是关于一个事件或对象(这里是一个西瓜)的描述，称为一个“示例”（instance)或“样 本”（sample).有时整个数据集亦称一个“样本”，因为它可看作对样本空间的一个采样; 通过上下文可判断出“样本”是指单个示例还是数据集。 属性（attribute）、特征（feature） 反映事件或对象在某方面的表现或性质的事项，例如“色泽” “根蒂”“敲声”，称为“属性”（attribute)或“特征”（feature). 属性值（attribute value） 属性上的取值，例如“青绿”“乌黑”，称为“属性值”（attribute value)“. “属性空间”（attribute space)、“样本空间”（sample space)或“输入空间” 属性合成的空间称为“属性空间”（attribute space)、“样本空间”（sample space)或“输入空间” 特征向量（feature vector） 例如我们把“色泽” “根蒂” “敲声”作为三个坐标轴，则它们张成 一个用于描述西瓜的三维空间，每个西瓜都可在这个空间中找到自己的坐标位 置.由于空间中的每个点对应一个坐标向量，因此我们也把一个示例称为一个 “特征向量”（feature vector). 维数（dimensionality） 一般地，令D = {x1x1 ,x2x2, …，xmxm}表示包含m个示例的数据集，每个示例由d个属性描述(例如上面的西瓜数据使用了3个属性)，则每个示例 xixi =(xi1xi1;xi2xi2;…x_id）是d维样本空间X 中的一个向量，xi∈xi∈X ,其中xijxij 是xixi在第j个属性上的取值(例如上述第3个西瓜在第2个属性上的值是“硬挺”），d 称为样本xixi的 “维数”（dimensionality). 学习、训练、训练数据、训练样本、训练集、假设、真相、真实、学习器 从数据中学得模型的过程称为“学习”（learning)或“训练”（training), 这个过程通过执行某个学习算法来完成.训练过程中使用的数据称为“训练 数据”（training data)，其中每个样本称为一个“训练样本”（training sample), 训练样本组成的集合称为“训练集”（training set).学得模型对应了关于数据的某种潜在的规律，因此亦称假设”（hypothesis);这种潜在规律自身，则称为“真相”或“真实” (ground-tmth),学习过程就是为了找出或逼近真相.有时将模型称为“学习器”（learner),可看作学习算法在给定数据和参数空间上的实例化. “训练示例” （training instance)、“训练例” 训练样本亦称“训练示例” （training instance)或“训练例”. 预测、标记、样例、标记空间、输出空间 学习算法通常有参数需设置，使用不同的参数值 和(或)训练数据，将产生不同的结果. 如果希望学得一个能帮助我们判断没剖开的是不是“好瓜”的模型，仅有前面的示例数据显然是不够的.要建立这样的关于“预测”（prediction)的模型，我们需获得训练样本的“结果”信息，例如“((色泽=青绿;根蒂=蜷缩; 敲声=浊响)，好瓜这里关于示例结果的信息，例如“好瓜”，称为“标记”（label);拥有了标记信息的示例，则称为“样例”（example).—般地，用(xixi，yiyi）表示第i个样例，其中队yi∈yi∈ * y * 是示例xixi的标记，* y * 是所有标记的集合, 亦称“标记空间”（label space)或“输出空间”. 将“label”译为“标记”而非“标签”，是考虑到英文中“label”既可用作名词、也可用作动词.若将标记看作对象本身的一部分，则“样例”有时也称为“样本”. 分类、回归、二分类、正类、反类、多分类 若我们欲预测的是离散值，例如“好瓜”“坏瓜”，此类学习任务称为“分类”（classification);若欲预测的是连续值，例如西瓜成熟度0.95、0.37, 此类学习任务称为“回归”（regression).对只涉及两个类别的“二分类”（binary classification)任务，通常称其中一个类为“正类”（positive class), 另一个类为“反类'(negative class);涉及多个类别时，则称为“多分类”（multi-class classification)任务.一般地，预测任务是希望通过对训练集{(x1,y1x1,y1),(x2,y2x2,y2)，…，(xm,ymxm,ym)}进行学习，建立一个从输入空间 * x * 到输出空间yy的映射ff:X⟼YX⟼Y 对二分类任务，通常令yy = {-1, +1}或{0, 1};对多分类任务，|yy|&gt; 2;对回归任务,yy = RR，RR为实数集. 学得模型后，使用其进行预测的过程称为“测试”（testing)，被预测的样本 称为“测试样本”（testing sample).例如在学得ff后，对测试例xx可得到其预 测标记y=f(x)y=f(x) 亦称“测试示例”（testing instance） 或“测试例” 聚类、簇 我们还可以对西瓜做“聚类”（clustering)，即将训练集中的西瓜分成若干 组，每组称为一个“簇”（cluster);这些自动形成的簇可能对应一些潜在的概念划分，例如“浅色瓜”“深色瓜”，甚至“本地瓜”“外地瓜”.这样的学习过程有助于我们了解数据内在的规律，能为吏深入地分析数据建立基础.需说明 的是，在聚类学习中，“浅色瓜” “本地瓜”这样的概念我们事先是不知道的， 而且学习过程中使用的训练样本通常不拥有标记信息. 监督学习、无监督学习 根据训练数据是否拥有标记信息，学习任务可大致划分为两大类：“监督学习 ”（supervised learning)和“无监督学习 ”（unsupervised learning),分类和回归是前者的代表，而聚类则是后者的代表. 亦称“有导师学习”和“无导师学习” 泛化能力 需注意的是，机器学习的目标是使学得的模型能很好地适用于“新样本”, 而不是仅仅在训练样本上工作得很好；即便对聚类这样的无监督学习任务，我们也希望学得的簇划分能适用于没在训练集中出现的样本.学得模型适用于新样本的能力，称为“泛化”（generalization)能力.具有强泛化能力的模型能 很好地适用于整个样本空间.于是，尽管训练集通常只是样本空间的一个很小的采样，我们仍希望它能很好地反映出样本空间的特性，否则就很难期望在训练集上学得的模型能在整个样本空间上都工作得很好.通常假设样本空间中全 体样本服从一个未知“分布”（distribution)DD，我们获得的每个样本都是独立地从这个分布上采样获得的，即“独立同分布”（independent and identically distributed，简称i.i.d.i.i.d.). —般而言，训练样本越多，我们得到的关于DD的信息越多，这样就越有可能通过学习获得具有强泛化能力的模型. 总结 假设空间 归纳(induction)与演绎(deduction)是科学推理的两大基本手段。前者是从特殊到一般的“泛化”（generalization)过程，即从具体的事实归结出一般性规律；后者则是从一般到特殊的“特化”（specialization)过程，即从基础原理推演 出具体状况.例如，在数学公理系统中，基于一组公理和推理规则推导出与之相洽的定理，这是演绎;而“从样例中学习”显然是一个归纳的过程，因此亦称 “归纳学习 ”（inductive learning) 。 归纳学习有狭义与广义之分，广义的归纳学习大体相当于从样例中学习， 而狭义的归纳学习则要求从训练数据中学得概念(concept)，因此亦称为“概念 学习”或“概念形成”.概念学习技术目前研究、应用都比较少，因为要学得 泛化性能好且语义明确的概念实在太困难了，现实常用的技术大多是产生“黑 箱”模型.然而，对概念学习有所了解，有助于理解机器学习的一些基础思想. 概念学习中最基本的是布尔概念学习，即对“是”“不是”这样的可表示 为0/1布尔值的目标概念的学习。 编号 色泽 根蒂 敲声 好瓜 1 青绿 蜷缩 浊响 是 2 乌黑 蜷缩 浊响 是 3 青绿 硬挺 清脆 否 4 乌黑 稍蜷 沉闷 否 (色泽=?)⋀(根蒂=?)⋀(敲声=?)↔好瓜 学习过程⟶⟶ 在所有假设(hypothesis)组成的空间中进行搜索的过程 目标: 找到与训练集“匹配”(fit)的假设 以西瓜问题假设为例。色泽属性可取（青绿，乌黑，浅白，* ），根蒂属性可取（蜷缩，稍蜷，硬挺，* ），敲声属性可取（浊响，清脆，沉闷，* ），以及好瓜假设不存在(ϕϕ)。即西瓜问题的假设空间大小为（4 * 4 * 4 + 1=65） 版本空间 可以有许多策略对这个假设空间进行搜索，例如自顶向下、从一般到特殊， 或是自底向上、从特殊到一般，搜索过程中可以不断删除与正例不一致的假设、和(或)与反例一致的假设.最终将会获得与训练集一致(即对所有训练样本 能够进行正确判断)的假设，这就是我们学得的结果. 需注意的是，现实问题中我们常面临很大的假设空间，但学习过程是基于有限样本训练集进行的，因此，可能有多个假设与训练集一致，即存在着一个与训练集一致的“假设集合”，我们称之为“版本空间”（version space) 归纳偏好 通过学习得到的模型对应了假设空间中的一个假设.于是，上面西瓜版本空间给我们带来一个麻烦：现在有三个与训练集一致的假设，但与它们对应的模型在面临新样本的时候，却会产生不同的输出.例如，对(色泽=青绿; 根蒂=蜷缩；敲声=沉闷)这个新收来的瓜，如果我们采用的是“好瓜⟷⟷(色泽=* )∧∧（根蒂=蜷缩）∧∧（敲声= * )”，那么将会把新瓜判断为好瓜，而如果釆用了另外两个假设，则判断的结果将不是好瓜.那么，应该采用哪一个模型(或 假设)呢？ 若仅有以上的训练样本，则无法断定上述三个假设中哪一个“更好”. 然而，对于一个具体的学习算法而言，它必须要产生一个模型.这时，学习算法本身的“偏好”就会起到关键的作用.例如，若我们的算法喜欢“尽可能特殊”的模型，则它会选择“好瓜⟷⟷(色泽=* )∧∧(根蒂=蜷缩）∧∧(敲声=浊响)”； 但若我们的算法喜欢“尽可能一般”的模型，并且由于某种原因它更“相信” 根蒂，则它会选择“好瓜⟷⟷ (色泽=* )∧∧(根蒂=蜷缩)∧∧(敲声=* )” .机器学习算法在学习过程中对某种类型假设的偏好，称为“归纳偏好”（inductive bias), 或简称为“偏好’ “奥卡姆剃刀”（Occam’s razor)是一种常用的、自然科学研究中最基本的原则，即“若有多个假设与观察一致，则选最简单的那个”.如果采用这个原则，并且假设我们认为“更平滑”意味着“更简单”（例如曲线 A更易于描述，其方程式是y=−x2+6x+1y=−x2+6x+1，而曲线B则要复杂得多) No Free Lunch Theoren 定理 ， 没有免费的午餐定理，简称NFL定理， 由美国斯坦福大学的Wolpert和Macready教授提出。 NFL定理：一个算法A若在某些问题上比另一个算法B好，必存在另一些问题B比A好 为简单起见，假设样本空间XX和假设空间HH都是离散的.令P(h|X,La)P(h|X,La)代表算法LaLa基于训练数据X产生假设hh的概率，再令ff代表我们希望学习的真实目标函数LaLa的“训练集外误差”，即LaLa在训练集之外的所有样本上的误差为 Eote(La∣X,f)=∑h∑x∈χ−XP(x)I(h(x)≠f(x))P(h∣X,La)Eote(La∣X,f)=∑h∑x∈χ−XP(x)I(h(x)≠f(x))P(h∣X,La)E_{ote}(La|X,f)=∑_{h}∑_{x∈χ−X}P(x)I(h(x)≠f(x))P(h|X,La)Eote(La|X,f)=∑h∑x∈χ−XP(x)I(h(x)≠f(x))P(h|X,La)Eote​(La∣X,f)=∑h​∑x∈χ−X​P(x)I(h(x)​=f(x))P(h∣X,La)Eote(La∣X,f)=∑h∑x∈χ−XP(x)I(h(x)​=f(x))P(h∣X,La) 其中I(⋅)I(⋅)是指示函数，若•为真则取值1,否则取值0. 考虑二分类问题，且真实目标函数可以是任何函数x⟼0,1x⟼0,1,函数空间为0,1|x|0,1|x|对所有可能的f按均匀分布对误差求和，有 ∑fEote(La∣X,f)=∑f∑h∑x∈χ−XP(x)I(h(x)≠f(x))P(h∣X,La)∑fEote(La∣X,f)=∑f∑h∑x∈χ−XP(x)I(h(x)≠f(x))P(h∣X,La)​∑_{f}E_{ote}(La|X,f)=∑f∑h∑x∈χ−XP(x)I(h(x)≠f(x))P(h|X,La)∑fEote(La|X,f)=∑f∑h∑x∈χ−XP(x)I(h(x)≠f(x))P(h|X,La)​∑f​Eote​(La∣X,f)=∑f∑h∑x∈χ−XP(x)I(h(x)​=f(x))P(h∣X,La)∑fEote(La∣X,f)=∑f∑h∑x∈χ−XP(x)I(h(x)​=f(x))P(h∣X,La)​ =∑x∈χ−XP(x)∑hP(h|X,La)∑fI(h(x)≠f(x))=∑x∈χ−XP(x)∑hP(h|X,La)∑fI(h(x)≠f(x)) =∑x∈χ−XP(x)∑hP(h|X,La)122|x|=∑x∈χ−XP(x)∑hP(h|X,La)122|x| =122|x|∑x∈χ−XP(x)∑hP(h|X,La)=122|x|∑x∈χ−XP(x)∑hP(h|X,La) =122|x|∑x∈χ−XP(x)⋅1=122|x|∑x∈χ−XP(x)⋅1$$ 上式显示出，总误差和学习算法无关！对于任意两个学习算法LaLa和LbLb,我们都有 ∑fEote(La|X,f)=∑fEote(Lb|X,f)∑fEote(La|X,f)=∑fEote(Lb|X,f) 也就是说，无论学习算法LaLa多聪明、学习算法LbLb多笨拙，它们的期望性能竟然相同！这就是“没有免费的午餐”定理（No FYee Lunch Theorem,简称NFL定理）[Wolpert，1996; Wolpert and Macready, 1995]. 总结 NFL定理有一个重要前提：所有“问题”出现的机会相同、或所有问题同等重要.但实际情形并不是这样.很多时候，我们只关注自己正在试图解决的问题(例如某个具体应用任务)，希望为它找到一个解决方案， 至于这个解决方案在别的问题、甚至在相似的问题上是否为好方案，我们并不关心.例如，为了快速从A地到达B地，如果我们正在考虑的A地是南京鼓楼、B地是南京新街口，那么“骑自行车”是很好的解决方案；这个方案对A 地是南京鼓楼、B地是北京新街口的情形显然很糟糕，但我们对此并不关心. NFL定理最重要的寓意，是让我们清楚地认识到，脱离具体问题，空泛地谈论“什么学习算法更好”毫无意义，因为若考虑所有潜在的问题，则所有学习算法都一样好.要谈论算法的相对优劣，必须要针对具体的学习问题；在某些问题上表现好的学习算法，在另一些问题上却可能不尽如人意，学习算法自身的归纳偏好与问题是否相配，往往会起到决定性的作用. 经验误差和过拟合 通常我们把分类错误的样本数占样本总数的比例称为“错误率”（error rate),即如果在m个样本中有a个样本分类错误，则错误率EE=a/m;相应的, l-a/m称为“精度” (accuracy),即“精度=1-错误率”.更一般地,我们把学习器的实际预测输出与样本的真实输出之间的差异称为“误差”（error), 学习器在训练集上的误差称为“训练误差”（training error)或“经验误差” (empirical error),在新样本上的误差称为“泛化误差”（generalization error).显然，我们希望得到泛化误差小的学习器.然而，我们事先并不知道新样本是什么样，实际能做的是努力使经验误差最小化.在很多情况下，我们可以学得一个经验误差很小、在训练集上表现很好的学习器，例如甚至对所有训练 样本都分类正确，即分类错误率为零，分类精度为100%,但这是不是我们想要的学习器呢？遗憾的是，这样的学习器在多数情况下都不好. 我们实际希望的，是在新样本上能表现得很好的学习器.为了达到这个目的，应该从训练样本中尽可能学出适用于所有潜在样本的“普遍规律”，这样才能在遇到新样本时做出正确的判别.然而,当学习器把训练样本学得“太好”了的时候，很可能已经把训练样本自身的一些特点当做了所有潜在样本都会具有的一般性质，这样就会导致泛化性能下降。这种现象在机器学习中称为 “过拟合”（overfitting).与“过拟合”相对的是“欠拟合”（underfitting),这是指对训练样本的一般性质尚未学好。 总结 有多种因素可能导致过拟合，其中最常见的情况是由于学习能力过于强大,以至于把训练样本所包含的不太一般的特性都学到了，而欠拟合则通常是由于学习能力低下而造成的.欠拟合比较容易克服，例如在决策树学习中扩展分支、在神经网络学习中増加训练轮数等，而过拟合则很麻烦.在后面的学习中我们将看到，过拟合是机器学习面临的关键障碍，各类学习算法都必然带有一些针对过拟合的措施;然而必须认识到，过拟合是无法彻底避免的，我们所能做的只是“缓解”，或者说减小其风险. 在现实任务中，我们往往有多种学习算法可供选择，甚至对同一个学习算法，当使用不同的参数配置时，也会产生不同的模型.那么，我们该选用哪一个学习算法、使用哪一种参数配置呢？这就是机器学习中的“模型选择”（model selection)问题.理想的解决方案当然是对候选模型的泛化误差进行评估，然后选择泛化误差最小的那个模型.然而如上面所讨论的，我们无法直接获得泛化误差，而训练误差又由于过拟合现象的存在而不适合作为标准，那么，在现实中如何进行模型评估与选择呢？ 如何获得测试结果？ ⟹⟹ 评估方法 如何评估性能优劣？ ⟹⟹ 性能度量 如何判断实质差别？ ⟹⟹ 比较检验 评估方法 测试集应该与训练集“互斥” 留出法 (hold-out) 交叉验证法 (cross validation) 自助法 (bootstrap) 留出法 留出法（hold-out)直接将数据集D划分为两个互斥的集合，其中一个集合S作为训练集另一个作为测试集T,即D=S∪TD=S∪T, S∩T=ϕS∩T=ϕ在SS上训练出模型后，用T来评估其测试误差，作为对泛化误差的估计. 交叉验证法 “交叉验证法”（cross validation)先将数据集DD划分为k个大小相似的互斥子集，即D=D1∪D2∪…∪DkD=D1∪D2∪…∪Dk , Di∩DJ=ϕDi∩DJ=ϕ(i≠ji≠j)每个子集DiDi都尽可能保持数据分布的一致性，即从DD中通过分层采样得到.然后，每次用 k - 1个子集的并集作为训练集，余下的那个子集作为测试集；这样就可获得k组训练/测试集，从而可进行k次训练和测试，最终返回的是这k个测试结果的均值.显然，交叉验证法评估结果的稳定性和保真性在很大程度上取决于k的取值，为强调这一点，通常把交叉验证法称为“k折交叉验证”（k-fold cross validation). k最常用的取值是10,此时称为10折交叉验证。 假定数据集DD中包含m个样本，若令k = m，则得到了交叉验证法的一个特例：留一法(Leave-One-Out，简称LOO).显然，留一法不受随机样本划分方式的影响，因为m个样本只有唯一的方式划分为m个子集每个子集包含一个样本；留一法使用的训练集与初始数据集相比只少了一个样本，这就使得在绝大多数情况下，留一法中被实际评估的模型与期望评估的用训练出的模型很相似.因此，留一法的评估结果往往被认为比较准确.然而，留一法也有其缺陷：在数据集比较大时，训练m个模型的计算开销可能是难以忍受的(例如数 据集包含1百万个样本，则需训练1百万个模型)，而这还是在未考虑算法调参的情况下.另外，留一法的估计结果也未必永远比其他评估方法准确；“没有免费的午餐”定理对实验评估方法同样适用. 扩展 我们希望评估的是用𝐷D训练出的模型.但在留出法和交叉验证法中，由于保留了一部分样本用于测试，因此实际评估的模型所使用的训练集比D小，这必然会引入一些因训练样本规模不同而导致的估计偏差.留一法受训练样本规模变化的影响较小，但计算复杂度又太高了.有没有什么办法可以减少训练样本规模不同造成的影响，同时还能比较高效地进行实验估计呢？ 自助法 “自助法”（bootstrapping)是一个比较好的解决方案，它直接以自助采样 法(bootstrap sampling)为基础[Efron and Tibshirani, 1993].给定包含m个样本的数据集DD,我们对它进行釆样产生数据集D′D′：每次随机从乃中挑选一个样本，将其拷贝放入D′D′,然后再将该样本放回初始数据集DD中,使得该样本在下次釆样时仍有可能被采到;这个过程重复执行m次后，我们就得到了包含m个样本的数据集D′D′，这就是自助采样的结果.显然，D中有一部分样本会在D′D′中多次出现，而另一部分样本不出现.可以做一个简单的估计，样本在m次采样中始终不被采到的概率是(1−1m)m(1−1m)m,取极限得到。 limm→∞(1−1m)m⟶1e≈0.368limm→∞(1−1m)m⟶1e≈0.368 即通过自助釆样，初始数据集乃中约有36.8%的样本未出现在釆样数据集D′D′中，于是我们可将D′D′用作训练集，D/D′D/D′用作测试集;这样，实际评估的模型与期望评估的模型都使用m个训练样本，而我们仍有数据总量约1/3的、没在训练集中出现的样本用于测试.这样的测试结果，亦称“包外估计”（out-of-bag estimate). 自助法在数据集较小、难以有效划分训练/测试集时很有用;此外，自助法能从初始数据集中产生多个不同的训练集，这对集成学习等方法有很大的好处. 然而，自助法产生的数据集改变了初始数据集的分布，这会引入估计偏差.因此,在初始数据量足够时，留出法和交叉验证法更常用一些. 性能度量 对学习器的泛化性能进行评估，不仅需要有效可的实验估计方法，还需要有衡量模型泛化能力的评价标准，这就是性能度量(performance measure).性能度量反映了任务需求，在对比不同模型的能力时，使用不同的性能度量往 往会导致不同的评判结果；这意味着模型的“好坏”是相对的，什么样的模型是好的，不仅取决于算法和数据，还决定于任务需求. 在预测任务中，给定样例集D=(x1，y1),(x2,y2),…,(xm.ym)D=(x1，y1),(x2,y2),…,(xm.ym),其中yiyi是示例xixi的真实标记.要评估学习器ff的性能，就要把学习器预测结果f(x)f(x)与真实标记yy进行比较. 回归任务最常用的性能度量是“均方误差”（mean squared error) E(f;D)=1m∑mi=1(f(xi)−yi)2E(f;D)=1m∑i=1m(f(xi)−yi)2 对于数据分布DD和概率密度函数p(⋅)p(⋅),均方误差可描述为 E(f;D)=∫x∼D（f(x)−y）2p(x)dxE(f;D)=∫x∼D（f(x)−y）2p(x)dx 错误率是分类错误的样本数占样本总数的比例 E(f;D)=1m∑mi=1I(f(xi)≠yi)E(f;D)=1m∑i=1mI(f(xi)≠yi) 精度则是分类正确的样本数占样本总数的比例 acc(f;D)=1m∑mi=1I(f(xi)=yi)acc(f;D)=1m∑i=1mI(f(xi)=yi) 错误率： E(f;D)=∫x∼DI（f(x)≠y）p(x)dxE(f;D)=∫x∼DI（f(x)≠y）p(x)dx 查准率：P=TPTP+FPP=TPTP+FP 查全率：R=TPTP+FNR=TPTP+FN 查准率和查全率是一对予盾的度量，一般来说，查准率高时，查全率往往偏低查全率高时.查准率偏低。 PR图，BEP（Break-Event Point） 根据学习器的预测结果按正例可能性大小对样例进行排序，并逐个把样本作为正例进行预测 比 BEP 更常用的 F1 度量： F1：F1=2PRP+R=2TP样例总数+TP−TNF1=2PRP+R=2TP样例总数+TP−TN 若对查准率/查全率有不同偏好： Fβ=(1+β2)PR(β2P)+RFβ=(1+β2)PR(β2P)+R β=1β=1时退化为标准的F1；β&gt;1β&gt;1时查全率有更大影响；β&lt;1β&lt;1时查准率有更大影响。 扩展 很多时候我们有多个二分类混淆矩阵 宏 macro−P=1n∑ni=1Pimacro−P=1n∑i=1nPi macro−R=1n∑ni=1Rimacro−R=1n∑i=1nRi macro−F1=2macro−P×macro−Rmacro−P+macro−Rmacro−F1=2macro−P×macro−Rmacro−P+macro−R 微 micro−P=PT¯¯¯¯¯¯¯¯TP¯¯¯¯¯¯¯¯+FP¯¯¯¯¯¯¯¯micro−P=PT¯TP¯+FP¯ micro−P=TP¯¯¯¯¯¯¯¯TP¯¯¯¯¯¯¯¯+FN¯¯¯¯¯¯¯¯¯micro−P=TP¯TP¯+FN¯ macro−F1=2macro−P×macro−Rmacro−P+macro−Rmacro−F1=2macro−P×macro−Rmacro−P+macro−R ROC 与 AUC ROC全称是“受试者工作特征”（Receiver Operating Characteristic）。ROC曲线的面积就是AUC（Area Under the Curve） TPR=TPTP+FNTPR=TPTP+FN FPR=FPTN+FPFPR=FPTN+FP AUC=12∑m−1∗i=1(x∗i+1−xi)⋅(yi+yi+1)AUC=\frac{1}{2}\sum^{m-1}*{i=1}(x*{i+1}-x_i)\cdot(y_i + y_{i+1})AUC=21​∑m−1∗i=1(x∗i+1−xi​)⋅(yi​+yi+1​) 代价敏感错误率与代价曲线 在现实任务中常会遇到这样的情况：不同类型的错误所造成的后果不同. 例如在医疗诊断中，错误地把患者诊断为健康人与错误地把健康人诊断为患者, 看起来都是犯了“一次错误”，但后者的影响是增加了进一步检查的麻烦，前者的后果却可能是丧失了拯救生命的最佳时机；再如，门禁系统错误地把可通行人员拦在门外，将使得用户体验不佳,但错误地把陌生人放进门内，则会造成严重的安全事故.为权衡不同类型错误所造成的不同损失，可为错误赋予“非 均等代”（unequal cost). 以二分类任务为例，我们可根据任务的领域知识设定一个“代价矩阵”（cost matrix)，其中costijcostij表示将第i类样本预测为第j类样本的代价.一般来说，costii=0costii=0;若将第0类判别为第1类所造成的损失更大，则cost01&gt;cost10cost01&gt;cost10;损失程度相差越大，cost01cost01与cost10cost10值的差别越大. 代价敏感（cost-sensitive）错误率E(f;D;cost)=1m(∑xi∈D+I(f(xi)≠yi)×cost01+∑xi∈D−I(f(xi)≠yi)×cost10)督的学习模型，通常用来进行模式识别、分类、以及回归分析。]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>人工智能</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数值类型与序列类型]]></title>
    <url>%2Fpython-numerical-sequence.html</url>
    <content type="text"><![CDATA[1. 数值类型 1.1 int（整型） 整型也就是我们日常中的整数，在Python中不需要声明变量，直接赋值即可 12a = 100print(type(a)) 1.2 float（浮点型） 基本情况 浮点型一般是我们常见的小数 12b = 2.2print(type(b)) decimal库 但是浮点数不是我们真正看到的数，比如1.2实际是1.1999999999 所以小数计算都是不精确的，那么我们如何进行精确计算呢？ 在Python中如果我们要实现精确计算，我们是使用decimal这个库函数 123456import decimal a = decimal.Decimal('2.2')b = decimal.Decimal('2')print(a-b) 基本整数与小数四则运算 计算机在计算的时候，除了整数运算，还有小数运算，还有小数和整数的混合运算 运算符 描述 实例 + 加 3 + 4 输出 7 - 减 8 - 6 输出 2 * 乘 3 * 4 输出 12 / 除 6 / 3 输出 2.0 // 向下取整 9 // 2 输出结果 4 , 9.0//2.0 输出结果 4.0 % 取余 6 % 4 输出 2 ** 幂 2 ** 3 输出 8 向上取整：使用math库函数 12import mathmath.ceil(2.3/2) # 2 ​ 1.3 bool（布尔类型） 布尔类型只有True和False两种值 ，在数值计算中，True表示1，False表示0。 1.4 complex （复数） 复数由实数部分和虚数部分构成，可以用a + bj,或者complex(a,b)表示， 复数的实部a和虚部b都是浮点型。 12345c = 5 + 6jd = complex(5,6)print(type(c))print(type(d)) 2. 序列类型 ​ 2.1 字符串（str） ​ 字符串的表示形式 ​ 在Python3中字符串有3中表示方式，如下 a. 使用单引号（’） 12st1 = 'hello world'print(st1) b. 使用双引号（&quot;） 12st2 = "hello world" #双引号中的字符串与单引号中的字符串用法完全相同print(st2) c. 使用三引号（’’’） 123st2 = '''helloworld''' #三引号可表示多行的字符串，可以在三引号中自由的使用单引号和双引号print(st2) ​ 字符串的使用 字符串的截取，语法格式如下 1变量[头下标:尾下标] #索引值以 0 为开始值，-1 为从末尾的开始位置。 实例如下 123456789st2 = &apos;Runoob&apos; print (st2) # 输出字符串print (st2[0:-1]) # 输出第一个到倒数第二个的所有字符print (st2[0]) # 输出字符串第一个字符print (st2[2:5]) # 输出从第三个开始到第五个的字符print (st2[2:]) # 输出从第三个开始的后的所有字符print (st2 * 2) # 输出字符串两次print (st2 + &quot;TEST&quot;) # 连接字符串 ​ Python 使用反斜杠\转义特殊字符，如果你不想让反斜杠发生转义，可以在字符串前面添加一个 r，表示原始字符串： 12345print('楽\no')#输出：楽# oobprint(r'楽\no')#输出：楽\no 另外，反斜杠\可以作为续行符，表示下一行是上一行的延续。也可以使用 “”&quot;…&quot;&quot;&quot; 或者 ‘’’…’’’ 跨越多行。 总结： 反斜杠可以用来转义，使用r可以让反斜杠不发生转义。 字符串可以用+运算符连接在一起，用*运算符重复。 Python中的字符串有两种索引方式，从左往右以0开始，从右往左以-1开始。 Python中的字符串不能改变 。 ​ 2.2 列表（list） ​ 列表可以完成大多数集合类的数据结构实现。列表中元素的类型可以不相同，它支持数字，字符串甚至可以包含列表（所谓嵌套）。 列表是写在方括号[] 之间,用逗号分隔开的元素列表。 12list0 = [1,'a',[2]]print(type(list0)) ​ 和字符串一样，列表同样可以被索引和截取，列表被截取后返回一个包含所需元素的新列表。 123456789list1 = ['abcd',786,2.23,'楽',70.2 ]list2 = [123, '楽'] print (list1) # 输出完整列表print (list1[0]) # 输出列表第一个元素print (list1[1:3]) # 从第二个开始输出到第三个元素print (list1[2:]) # 输出从第三个元素开始的所有元素print (list2 * 2) # 输出两次列表print (list1 + list2) # 连接列表 与Python字符串不一样的是，列表中的元素是可以改变的 12345678a = [1, 2, 3, 4, 5, 6]a[0] = 9a[2:5] = [13, 14, 15]print(a) #[9, 2, 13, 14, 15, 6]a[2:5] = [] # 将对应的元素值设置为 [] print(a) #[9, 2, 6] 总结： List写在方括号之间，元素用逗号隔开。 和字符串一样，list可以被索引和切片。 List可以使用+操作符进行拼接。 List中的元素是可以改变的。 ​ 2.3 元组 ​ 元组（tuple）与列表类似，不同之处在于元组的元素不能修改。元组写在小括号 ()里，元素之间用逗号隔开。 123456789tup = ( 'abcd', 786 , 2.23, '楽', 70.2 )tinytup = (123, '楽') print (tup) # 输出完整元组print (tup[0]) # 输出元组的第一个元素print (tup[1:3]) # 输出从第二个元素开始到第三个元素print (tup[2:]) # 输出从第三个元素开始的所有元素print (tinytup * 2) # 输出两次元组print (tup + tinytup) # 连接元组 元组与字符串类似，可以被索引且下标索引从0开始，-1 为从末尾开始的位置。也可以进行截取。 虽然tuple的元素不可改变，但它可以包含可变的对象，比如list列表。 构造包含 0 个或 1 个元素的元组比较特殊，所以有一些额外的语法规则： 12tup1 = () # 空元组tup2 = (20,) # 一个元素，需要在元素后添加逗号 总结： 与字符串一样，元组的元素不能修改。 元组也可以被索引和切片，方法一样。 注意构造包含 0 或 1 个元素的元组的特殊语法规则。 元组也可以使用+操作符进行拼接。 ​ 3. 扩展 类型转换 字符串转列表 123456a = 'abcd'b = list(a)print(type(a))print(type(b))print(b) #['a', 'b', 'c', 'd'] 列表转字符串 123456a = ['a', 'b', 'c', 'd']b = str(a)print(type(a))print(type(b))print(b) #"['a', 'b', 'c', 'd']" 字符串转元组 123456a = 'abcd'b = tuple(a)print(type(a))print(type(b))print(b) #('a', 'b', 'c', 'd') ​ 元组转字符串 123456a = ('a', 'b', 'c', 'd')b = str(a)print(type(a))print(type(b))print(b) #"('a', 'b', 'c', 'd')" ​ 拆包 ​ 元组拆包可以应用到任何迭代对象上， 唯一的要求是， 被可迭代对象中的元素数量必须要和这些元素的元组的空档数一致， 除非我们用*来表示忽略多余的元素。 123456a = ('a', 'b', 'c', 'd')x,*y,z = aprint(x) #'a'print(z) #'d'print(y) #['b', 'c'] x 接收第一个元素，z 接收最后一个元素，由于y前面有*号，所以剩余的元素由y接收 总结：有多少个元素就需要多少个变量来接收，除非有*号，不然就会报错. ​ 变量赋值 ​ 变量的保存都是保存在内存中 注意：变量是没有类型的，有类型的是他所指向的数据 12345678910 a = 123b = 'abc'print（id(a)） # 10923232print(id(b)) # 140343125492152#id()：查看数据的地址a = '111'print（id(a)） # 140342939172344 赋值给变量是保存在内存中，重新赋值后，变量指向新的地址 ​ 变量的引用-成员运算 ​ 通过in或者not in 来进行成员运算 123456a = 'abcd123'print('c' in a) #Trueprint('8' in a) #Falseprint('a' not in a) #Falseprint('q' not in a) #True]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python基础</tag>
        <tag>数据类型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JQuery]]></title>
    <url>%2FJQuery.html</url>
    <content type="text"><![CDATA[1. JQ简介 1.1 什么是JQ ​ JQ是JS写的插件库，说白了，就是一个js文件 1.2 JS和JQ是区别 ​ 凡是用jq能实现的，js都能实现，js能实现的，jq却不一定能实现 1.3 JQ的理念 ​ 减少代码量，提高工作效率 1.4 JQ的引入 1.4.1 本地文件引入 1&lt;script src="js/jquery-3.2.1.js"&gt;&lt;/script&gt; 1.4.2 CDN引入 1&lt;script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.js"&gt;&lt;/script&gt; 相应网站：https://www.bootcdn.cn/jquery/ 2. JQ的基本使用 在JavaScript中，用$声明使用的是jQuery,例如： 1234567&lt;button class="btn"&gt;点我&lt;/button&gt;&lt;script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.js"&gt;&lt;/script&gt;&lt;script&gt; $('button').click(function()&#123; alert(123);//点击button时弹出123 &#125;)&lt;/script&gt; 2.1 JQ的选择器 在jQ中使用选择器选择元素和在CSS中使用CSS选择器是一样的 ，上面那个例子： 123456789&lt;script&gt; $('button').click(function()&#123;//使用的是标签选择器 alert(123); &#125;) $('#btn').click(function()&#123;//使用的是类选择器 alert(123); &#125;)&lt;/script&gt; 当然在使用过程中也可以用后代选择器，兄弟选择器之类的选择器 2.2 基本使用1 我们首先看下面代码，方便后面讲解 123456789101112131415161718&lt;div id="div1"&gt; &lt;p id="p1" class="p11"&gt;我是段落标签一&lt;/p&gt; &lt;p id="p2" class="p11"&gt;我是段落标签二&lt;/p&gt; &lt;p id="p3" class="p11"&gt;我是段落标签三&lt;/p&gt; &lt;span&gt;我是文本标签一&lt;/span&gt; &lt;span&gt;我是文本标签二&lt;/span&gt; &lt;ul&gt; &lt;li&gt;0&lt;/li&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;li&gt;4&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;&lt;script&gt; var p1 = document.getElementById("p1"); $("#p1");&lt;/script&gt; 2.2.1 JS与JQ之间的转换 (1) jq转js：get()与[] 12$("p").get(2).innerText = '1111111';$("p")[1].innerText = '222222'; get()与[]中填写索引值，然后对其进行操作。 (2) js转jq 用$()将js定义的变量括起来，如： 1$(p1) //js转jq html() 1$(p1).html(123123); //html等同于js的innerHtml text() 1$(p1).text(123123); //text等同于js的innerText 2.2.2 鼠标事件 (1) 单击：click() 123$(&quot;#p1&quot;).click(function () &#123; alert(123) &#125;); (2) 鼠标移入移出 12345$("#p1").hover(function () &#123; $("#p2").html("鼠标移入效果") //鼠标移入 &#125;,function () &#123; $("#p2").html("鼠标移出效果") //鼠标移出 &#125;); 2.2.3 追加与添加 12$("#p1").append("&lt;p&gt;我是p1的兄弟&lt;/p&gt;"); //将双引号内的内容追加到#p1后面$("#p1").prepend("&lt;p&gt;我也是p1的兄弟&lt;/p&gt;"); //将双引号内的内容添加到#p1前面 2.2.4 遍历：each 1234$("ul li").each(function (i) &#123; $(this).html("我是第"+i+"个") //this是指遍历的当前的对象自己 alert($(this).index()); //弹出遍历的当前的对象的索引值 &#125;); 2.2.5 操作属性 12$("#div1").attr("class","b"); //添加类属性，类名为b$("#div1").removeAttr("class") //删除属性class 2.2.6 操作class类名 12$("#div1").addClass("div321"); //添加类名$("#div1").removeClass(); //删除类名 2.2.7 判断属性 1alert($("#div1").hasClass("div222")); //判断div1中是否存在类名为div222 2.2.8 滚动条事件 1234$(window).scroll(function () &#123; console.log($(document).scrollTop()); //打印滚动条与顶部的距离 console.log($(document).scrollLeft()) //打印滚动条与左边的距离&#125;) 2.2.9 查找元素 12345console.log($("#div1").parent()); //查找父级元素bodyconsole.log($("#div1").children()); //查找子级元素console.log($("#p1").siblings()); //查找兄弟元素console.log($("#div1").find("span")); //查找后代元素console.log($("#sp1").parents("p")); //查找祖辈元素]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>jq</tag>
        <tag>html</tag>
        <tag>web</tag>
        <tag>网页</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript-03]]></title>
    <url>%2FJavaScript-03.html</url>
    <content type="text"><![CDATA[Math方法 sqrt：开方 abs：绝对值 PI：π pow(x,y) ：x的y次方 round：取整（四舍五入） random：随机数0~1 min（x，y，z）：从x，y，z中取最小值 max（x，y，z）：从x，y，z中取最大值 ceil：向上取整 floor：向下取整 例： 1Math.round(Math.random*100) //随机生成1~100的随机数 日期对象 Date方法 new Date()：新建日期对象 getFullYear：获取年份 getMonth：获取月份 getDay：获取日 getHours：获取时 getMinutes：获取分 getSeconds：获取秒 例： 12345678var today = new Date();var year = today.getFullYear();var month = today.getMonth()+1;var day = today.getDay();var hour = today.getHours();var minute = today.getMinutes(); var second = today.getSeconds();console.log(year+&apos;年&apos;+month+&apos;月&apos;+day+&apos;日&apos;+hour+&apos;:&apos;+minute+&apos;:&apos;+second); 时间戳 时间戳：格林威治时间1970年01月01日00时00分00秒(北京时间1970年01月01日08时00分00秒)起至现在的总秒数。 123var timestamp = Date.new();//新建console.log(&quot;timestamp:&quot;timestamp); 函数 函数的定义 函数是通常是把一系列重复使用的操作封装成一个方法，方便调用 函数分类：有名函数，匿名函数 定义有名函数: 1234function 函数名()&#123; //代码块 console.log(&quot;OK&quot;)&#125; 自定义函数： 123var result=function 函数名()&#123; //代码块&#125; 调用函数 1函数名(); 匿名函数： ​ 匿名函数一般充当事件函数 例： 1234567var box = document.getElementById(&apos;box&apos;);box.onclick = function()&#123; console.log(123);&#125;; 自调用函数： 自调用函数是在函数表达式写完后自动执行 其函数表达式前面加上 (,),+,-,!,~ 例： 1234567(function()&#123; console.log(&quot;ok&quot;);&#125;)();+function()&#123; console.log(&quot;ok&quot;);&#125;(); 函数参数： 12345function sum()&#123; var a = x+y+z； //需要传入3个参数x，y，z console.log(argments); //argments为接收的不定参数 console.log(a)&#125; 定时器 setTimeout：设置定时器 clearTimeout：清除定时器 setInterval：设置定时器 clearInterval：清除定时器 注：清除定时器的时候，要给定时器加个名字 例： 12345678910111213141516var btn = document.getElementsByTagName(&quot;button&quot;)[0]; //1000毫秒=1秒setTimeout(function () &#123; console.log(123) &#125;,1000);var timer = setInterval(function () &#123; console.log(123)&#125;,1000);btn.onclick = function () &#123; clearInterval(timer);&#125;; setTimeout与setInterval的区别 setTimeout执行一次，setInterval一直循环执行，直到清除定时器]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>网页</tag>
        <tag>js</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript-02]]></title>
    <url>%2FJavaScript-02.html</url>
    <content type="text"><![CDATA[JavaScript操作符 运算符 关系运算符 &gt; &lt; &gt;= &lt;= != == === !== ​ ==:比较数据 不比较类型 ​ ===：比数据比类型 . 逻辑运算符 &amp;&amp;逻辑与 || 逻辑或 ！逻辑非 算术运算符 + － * / % ++ －－ += *= /= 赋值运算符 = 条件运算符 （三目运算符 三元运算符）？： 操作符 typeof 判断变量的数据类型 两种写法 typeof 变量名 typeof （变量名） number --如果这个字值是数值 string --如果这个字值是字符串 undefined --如果这个字值是未定义 boolean --如果这个字值是布尔值 object --如果这个字值是对象或null function --如果这个字值是函数 JavaScript控制流程语句 选择结构 ​ if…else ​ switch…case(可以使用字符串) 循环结构 ​ for ​ do…while ​ while ​ for in for(var i in 数组名) i 代表数组下标，只能放在数组中 跳转语句 ​ break ​ continue 常用方法 字符串的常用方法 lenght; 长度 []/get（）;下标 Replace（）;替换 Split（）; 分割 Slice（）;切割 Substring（）;截取 toUpperCase（）;转大写 toLowerCase（）;转小写 isnan（）;–判断是否为数值类型 --true 不是数值 --false 是数值 parseint（）; 转数值类型 parsefloat（）; 转小数类型 字符串函数 ​ indexof（&quot;&quot;） ​ 字符串.indexof（“a”）; --返回a字符 在字符串中的下标 从0开始，如果未找到返回-1 数组的常用方法 length;长度 [];下标 push（）;右加 Unshift（）;左家 Pop（）;右删 Shift（）;左删 Concat（）;连接 Reverse（）;反向 Sort（）;排序 join（）;拼接 splice（）;替换 slice（）;切片 indexOf（）;索引]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>网页</tag>
        <tag>js</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript-01]]></title>
    <url>%2FJavaScript-01.html</url>
    <content type="text"><![CDATA[1. 简介 javaScript简称 — js 网页三剑客： ​ html、css、js JavaScript简介： 1995年由 netspace和sun合作制作 一种基于对象（object）和事件驱动并具有相对安全性的客户端脚本语言 特点 是一种可以和html标记语言混合使用的脚本语言，不能单独运行 ECMA（欧洲计算机商协会）的标准，支持大部分浏览器 注意事项 严格区分大小写 每一行完整的语句后都要加分号 变量名不能使用关键字 代码要注意缩进，保持代码可读性 2. 如何使用JavaScript 1234567891011121314151617181920212223242526272829&lt;html&gt;``` &lt;head&gt;&lt;/head&gt; &lt;body&gt;&lt;/body&gt;```&lt;/html&gt;```1.嵌套 一般放在head中&lt;script type="text/javascript"&gt; //代码&lt;/script&gt;2.引用外部js文件&lt;script type="text/javascript" src="js文件地址"&gt;&lt;/script&gt;3.行级&lt;button onclick="javascript:alert('123')"&gt;按钮&lt;/button&gt;``` 获取元素 getElementById id-通过ID获取元素 getElementsByClassName class-通过class名字获取 getElementsByTagName tagName-通过标签名获取元素 getElementsByName name-通过属性名获取元素，一般用于input selector-通过CSS选择器获取一个 selectorAll-通过CSS选择器获取所有 简单事件 鼠标事件： onclick --单击事件 ondbclick --双击事件 onmouseenter --鼠标划入 onmouseleave --鼠标划出 onresize --窗口变化 onchange --改变下拉框 数据类型 数据类型（6种 5种简单数据类型，一种复杂数据类型）弱类型 弱类型 number 数值型 不区分整数和浮点数，没有限制长度 string 字符串 undefined 未定义 专门用来确定一个变量是否有初始值 . null 空 用于表明某个变量的值为空 boolean 布尔型 还有一种复杂性数据类型 object 对象 属性操作 - 合法属性及自定义属性(增删改查) 变量名.classname=‘box’; 增（无则增有则改） console.log(变量名.className); 查 变量名.reremoveAttribute(‘属性名’) 删 classname/removeAttribute setAttribute 增加效果（无则增有则改） hasAttritube 查找 removeAttribute 删除效果]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>网页</tag>
        <tag>js</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS进阶]]></title>
    <url>%2Fcss-02.html</url>
    <content type="text"><![CDATA[1. 盒子模型 可以把页面上的元素看成一个盒子 盒子模型由内容、内边距、边框、外边距构成 padding - 内边距 margin - 外边距 ☆ border - 边框 content(width、height) - 内容 border-top: 上边框 border-right: 右边框 border-left: 左边框 border-bottom: 下边框 double 双线 dotted 点 dashed 虚线 solid 实线 padding、margin - 参数 上右下左 顺时针 px 像素 2. Reset 重置 Reset - 重置CSS 浏览器解析标签的时候本身自带一些样式，有时会导致我们自身写的样式出现的效果不一致 每个公司会根据自己的业务需求写一套属于自己的ResetCss 以下是一个通用的RESETCSS： https://meyerweb.com/eric/tools/css/reset/ 3. 浮动 float:left 向左浮动 float:right 向右浮动 使用浮动须知： - 要先改成内联块状 - 脱离文档流 - 可能会造成高度塌陷 三种解决方法： 1、overflow:hidden;不推荐只适用于纯浮动的页面布局 2、加一个空的&lt;div&gt;&lt;/div&gt;;也不推荐 3、.clearfix::{ display:block; clear:both; content:''; 空字符 } 推荐 比较常用 4. 定位 作用：对元素进行精确的定位 三种形式 1、绝对定位:position:absolute; 绝对定位是脱离文档流的 2、相对定位:posttion:relative; 3、固定定位:position:fixed; 固定定位与相对定位不脱离文档流，是相对于自己的一个偏移 父相（对）子绝（对）：保持页面的布局完整]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>html</tag>
        <tag>web</tag>
        <tag>网页</tag>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS基础]]></title>
    <url>%2Fcss-01.html</url>
    <content type="text"><![CDATA[1. CSS的基本使用 行内样式： 行内样式可直接写在现有的HTML标签里,比如： 123&lt;p style="color:red;font-size:12px;"&gt;233333333&lt;/p&gt; 内部样式 内部样式把CSS样式直接写在当前页面的头部标签中 12345&lt;style type="tsxt/css"&gt; 样式规则：选择器&#123;属性：属性值&#125;&lt;/style&gt; 外部样式 外部样式是把CSS样式写在外部CSS文件中，通过嵌在页面的头部标签中 123&lt;link rel="stylesheet" href="要引入的网址"&gt; 2. 选择器 基本 标签选择器 标签名 类选择器 . ID选择器 # 其他 后代 .div span 子代 .div&gt;span 兄弟 .div~span 向下执行相同的 相邻 .div+span 全选择器 * div,span{ } 可以节省重复代码 伪类选择器 link 未访问的 visited 访问后的 hover 划过 active 激活状态的 3. 字体 font属性 常见的文本样式： color：字体颜色 font-size：字体大小 font-family：字体类型 &lt;strong&gt;：字体加粗 font-weight：bold 字体加粗 &lt;em&gt; 斜体 font-style：italic斜体 normal（正常） div--层标签 text-decoration：underline(有下划线) none(无下划线)设置下划线 line-through:删除线 text-align：center 文本居中对齐方式 left：对左 right：对右 line-height：行间距 letter-spacing:字符间距 border-radius: px text-indent: 2em首行缩进 Div+css布局方式 height+line-height文字上下居中 test-align：center文字水平居中 背景属性 background-color:背景颜色 background-image:url(图片路径); background-repeat:no-repeat;图片不重复 background-repeat:repeat-x(向x轴延伸) background-repeat:repeat-y(向y轴延伸) background-position:图片偏移; dispaly:inline; 转内联 dispaly:block; 转块状 dispaly:inline-block; 转内联块状]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>html</tag>
        <tag>web</tag>
        <tag>网页</tag>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML介绍及常用标签]]></title>
    <url>%2Fhtml.html</url>
    <content type="text"><![CDATA[1. HTML简介 超文本标记语言 Hyper(超)Text(文本)MarKup(标记)Language(语言) HTML是一门标记语言，标记语言就是靠标签组成，学习HTML就是学习标签的使用 HTML代码在执行过程中是从上往下执行的 什么是标签 由尖括号包裹单词构成，所以标签不可能以数字开头 不区分大小写，推荐小写 标签可以嵌套，不能交叉嵌套 2. 常用标签 初始标签 title:标题标签 head:头部标签 ​body:主体标签 常见标签 h1-h6:文章标题 p:段落标签 span:用来组合文档中的行内元素 strong/b:加粗 i:斜体 s:删除线 块状标签和内联标签(行内标签) 块状：霸道 独占一行，前后自动换 行，可以设置宽高 内联(行内)：在一行直到满了为止换行 列表 有序列表：ol li 无序列表：ul li 定义列表：dl dt dd 图片 src = 图片 …/ 相对路径 直接从电脑的是绝对路径 超链接(a标签) 123&lt;a href=" " target=" " title=" " &gt; href = 跳转的路径 target 打开方式，默认 self 在本身打开，blank 在新的空白页面打开 title 鼠标下方提示文本 特殊标签 &amp;nbsp 空格 &amp;lt 小于 &amp;gt 大于 &amp;emsp 字符宽 表格(table) table:表格标签 thead:表格头部 tbody:表格主题 tfoot:表格脚部 tr:行 td:列 colspan:合并列 rowspan:合并行 表单(from) 123&lt;from action=" " method=" " &gt; action:提交到的路径 method:提交的方式 ​ 默认值是 get ，会在地址栏显示安全性较差，对于提交的内容有长度限制 ​ post 不会显示在地址栏相对安全，对于提交的内容没有长度限制 input标签 文 本 框: 123&lt;input type="text" value="" maxlength="可输入的最大长度" size="" /&gt; 提交按钮: 123&lt;input type="submit" value="提交" /&gt; 普通按钮: 123&lt;input type="button" value="普通按钮" /&gt; 密 码 框: 123&lt;input type="password" /&gt; 重置按钮: 123&lt;input type="reset" value="重置" /&gt; 单选按钮: 123&lt;input type="radio" /&gt;name必须设置成一样的,表示是一组单选按钮 checked="checked"默认选中 文件上传域: 123&lt;input type="file"/&gt; 多选按钮: 123&lt;input type="checkbox" /&gt;name可以设置成不一样的,要求设置成一样的 下 拉 框: 123&lt;select&gt;&lt;option&gt;&lt;/option&gt;&lt;/select&gt; 多行文本域: 123&lt;textarea rows="行" cols="列"&gt;&lt;/textarea&gt; 隐 藏 域: 123&lt;input type="hidden" /&gt; 图片按钮: 123&lt;input type="image" src= "" onmouseover/&gt; 3. 扩展 在输入框中输入要搜索的信息，点击”百度一下“则跳转到百度对应的搜索信息，代码如下： 123456&lt;form action="https://www.baidu.com/s" method="get"&gt; 百度搜索 &lt;input type="text" placeholder="请输入搜索内容" name='wd'&gt; &lt;input tpye='submit' name='百度一下'&gt;&lt;/form&gt;]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>html</tag>
        <tag>web</tag>
        <tag>网页</tag>
      </tags>
  </entry>
</search>
