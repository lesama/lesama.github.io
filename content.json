{"meta":{"title":"嘿!楽","subtitle":"这里是楽的个人博客~","description":"这是里 楽 的个人博客","author":"楽","url":"https://lesama.github.io"},"pages":[{"title":"关于我","date":"2018-12-31T16:00:01.000Z","updated":"2019-01-23T17:17:59.531Z","comments":true,"path":"about/index.html","permalink":"https://lesama.github.io/about/index.html","excerpt":"","text":"关于我一个喜欢研究一些新技术的奇怪人。 平时喜欢写写文章，看看书，逛逛技术论坛，折腾新东西。 了解前端、python、MachineLearning、DeepLearning。 博客内容 python 前端 爬虫 机器学习 深度学习 强化学习 相关项目 相关工具"},{"title":"categories","date":"2019-03-04T07:05:29.000Z","updated":"2019-03-04T07:07:29.561Z","comments":true,"path":"categories/index.html","permalink":"https://lesama.github.io/categories/index.html","excerpt":"","text":""},{"title":"schedule","date":"2019-03-07T10:56:05.000Z","updated":"2019-03-07T10:57:01.875Z","comments":true,"path":"schedule/index.html","permalink":"https://lesama.github.io/schedule/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-03-04T07:07:42.000Z","updated":"2019-03-04T07:09:14.052Z","comments":true,"path":"tags/index.html","permalink":"https://lesama.github.io/tags/index.html","excerpt":"","text":""},{"title":"","date":"2019-03-02T16:39:29.721Z","updated":"2019-03-02T16:39:29.721Z","comments":true,"path":"lib/canvas-nest/README.html","permalink":"https://lesama.github.io/lib/canvas-nest/README.html","excerpt":"","text":"canvas-nest.js for NexT Installation Step 1 &rarr; Go to NexT dir Change dir to NexT directory. There must be layout, source, languages and other directories: 123$ cd themes/next$ lsbower.json _config.yml docs gulpfile.coffee languages layout LICENSE.md package.json README.md scripts source test Step 2 &rarr; Get module Install module to source/lib directory: 1$ git clone https://github.com/theme-next/theme-next-canvas-nest source/lib/canvas-nest Step 3 &rarr; Set it up Enable module in NexT _config.yml file: 1234567canvas_nest: enable: true onmobile: true # display on mobile or not color: '0,0,255' # RGB values, use ',' to separate opacity: 0.5 # the opacity of line: 0~1 zIndex: -1 # z-index property of the background count: 99 # the number of lines And, if you wants to use the CDN, then need to set: 1234vendors: ... canvas_nest: //cdn.jsdelivr.net/gh/theme-next/theme-next-canvas-nest@1.0.0/canvas-nest.min.js canvas_nest_nomobile: //cdn.jsdelivr.net/gh/theme-next/theme-next-canvas-nest@1.0.0/canvas-nest-nomobile.min.js Update 12$ cd themes/next/source/lib/canvas-nest$ git pull"},{"title":"","date":"2019-03-02T16:39:29.723Z","updated":"2019-03-02T16:39:29.723Z","comments":true,"path":"lib/canvas-nest/canvas-nest.min.js","permalink":"https://lesama.github.io/lib/canvas-nest/canvas-nest.min.js","excerpt":"","text":"!function(){function o(w,v,i){return w.getAttribute(v)||i}function j(i){return document.getElementsByTagName(i)}function l(){var i=j(\"script\"),w=i.length,v=i[w-1];return{l:w,z:o(v,\"zIndex\",-1),o:o(v,\"opacity\",0.5),c:o(v,\"color\",\"0,0,0\"),n:o(v,\"count\",99)}}function k(){r=u.width=window.innerWidth||document.documentElement.clientWidth||document.body.clientWidth,n=u.height=window.innerHeight||document.documentElement.clientHeight||document.body.clientHeight}function b(){e.clearRect(0,0,r,n);var w=[f].concat(t);var x,v,A,B,z,y;t.forEach(function(i){i.x+=i.xa,i.y+=i.ya,i.xa*=i.x>r||i.xn||i.y"},{"title":"","date":"2019-03-02T16:39:29.722Z","updated":"2019-03-02T16:39:29.722Z","comments":true,"path":"lib/canvas-nest/canvas-nest-nomobile.min.js","permalink":"https://lesama.github.io/lib/canvas-nest/canvas-nest-nomobile.min.js","excerpt":"","text":"!function(){ var userAgentInfo = navigator.userAgent; var Agents = [\"iPad\", \"iPhone\", \"Android\", \"SymbianOS\", \"Windows Phone\", \"iPod\", \"webOS\", \"BlackBerry\", \"IEMobile\"]; for (var v = 0; v < Agents.length; v++) { if (userAgentInfo.indexOf(Agents[v]) > 0) { return; } } function o(w,v,i){return w.getAttribute(v)||i}function j(i){return document.getElementsByTagName(i)}function l(){var i=j(\"script\"),w=i.length,v=i[w-1];return{l:w,z:o(v,\"zIndex\",-1),o:o(v,\"opacity\",0.5),c:o(v,\"color\",\"0,0,0\"),n:o(v,\"count\",99)}}function k(){r=u.width=window.innerWidth||document.documentElement.clientWidth||document.body.clientWidth,n=u.height=window.innerHeight||document.documentElement.clientHeight||document.body.clientHeight}function b(){e.clearRect(0,0,r,n);var w=[f].concat(t);var x,v,A,B,z,y;t.forEach(function(i){i.x+=i.xa,i.y+=i.ya,i.xa*=i.x>r||i.xn||i.y"}],"posts":[{"title":"机器学习-线性回归算法python实现","slug":"2019-03-10-ml-linearRegression-python","date":"2019-03-10T03:13:02.000Z","updated":"2019-03-10T11:11:09.478Z","comments":true,"path":"2019-03-10-ml-linearRegression-python.html","link":"","permalink":"https://lesama.github.io/2019-03-10-ml-linearRegression-python.html","excerpt":"","text":"线性回归算法python实现导入所需要的库文件123import matplotlib.pyplot as plt # 导入可视化库import numpy as np # 导入数据处理库from sklearn import datasets # 导入sklearn自带的数据集 把我们的参数值求解公式转换为代码求解的公式： $\\theta=(X^TX)^{-1}X^TY$ 12345def fit(self, X, y): # 训练集的拟合 X = np.insert(X, 0, 1, axis=1) # 增加一个维度 print (X.shape) X_ = np.linalg.inv(X.T.dot(X)) # 公式求解 -- X.T表示转置，X.dot(Y)表示矩阵相乘 self.w = X_.dot(X.T).dot(y) # 返回theta的值 其中：$(X^TX)^{-1}$表示为： 12X_ = np.linalg.inv(X.T.dot(X)) # 公式求解 -- X.T表示转置，X.dot(Y)表示矩阵相乘 np.linalg.inv() 表示求逆矩阵 其中：$X^TY $表示为： 1X.T.dot(X) 所以完整公式表示为：完整的公式：$\\theta=(X^TX)^{-1}X^TY$ 1X_.dot(X.T).dot(y) 由于我们最终得到的线性回归函数是即预测函数：线性回归方程：$y=\\theta x+b​$ 12345def predict(self, X): # 测试集的测试反馈 # 为偏置权值插入常数项 X = np.insert(X, 0, 1, axis=1) # 增加一个维度 y_pred = X.dot(self.w) # 测试集与拟合的训练集相乘 return y_pred # 返回最终的预测值 其中得到的预测结果$y_pred=X_text\\cdot\\theta$1y_pred = X.dot(self.w) # 测试集与参数值相乘 最终得出线性回归代码：123456789101112131415class LinearRegression(): def __init__(self): # 新建变量 self.w = None def fit(self, X, y): # 训练集的拟合 X = np.insert(X, 0, 1, axis=1) # 增加一个维度 print (X.shape) X_ = np.linalg.inv(X.T.dot(X)) # 公式求解 -- X.T表示转置，X.dot(Y)表示矩阵相乘 self.w = X_.dot(X.T).dot(y) # 返回theta的值 def predict(self, X): # 测试集的测试反馈 # 为偏置权值插入常数项 X = np.insert(X, 0, 1, axis=1) # 增加一个维度 y_pred = X.dot(self.w) # 测试集与拟合的训练集相乘 return y_pred # 返回最终的预测值 同时我们需要得出预测值与真实值的一个平方平均值1234def mean_squared_error(y_true, y_pred): #真实数据与预测数据之间的差值（平方平均） mse = np.mean(np.power(y_true - y_pred, 2)) return mse 最后就是进行我数据的加载，训练，测试过程以及可视化123456789101112131415161718192021222324252627def main(): # 第一步：导入数据 # 加载糖尿病数据集 diabetes = datasets.load_diabetes() # 只使用其中一个特征值 X = diabetes.data[:, np.newaxis, 2] print (X.shape) #第二步：将数据分为训练集以及测试集 x_train, x_test = X[:-20], X[-20:] y_train, y_test = diabetes.target[:-20], diabetes.target[-20:] #第三步：导入线性回归类（之前定义的） clf = LinearRegression() clf.fit(x_train, y_train) # 训练 y_pred = clf.predict(x_test) # 测试 #第四步：测试误差计算（需要引入一个函数） # 打印平均值平方误差 print (\"Mean Squared Error:\", mean_squared_error(y_test, y_pred)) #matplotlib可视化输出 # Plot the results plt.scatter(x_test[:,0], y_test, color='black') # 散点输出 plt.plot(x_test[:,0], y_pred, color='blue', linewidth=3) # 预测输出 plt.show() 可视化结果 完整线性回归的代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758import matplotlib.pyplot as plt # 导入可视化库import numpy as np # 导入数据处理库from sklearn import datasets # 导入sklearn自带的数据集import csvclass LinearRegression(): def __init__(self): # 新建变量 self.w = None def fit(self, X, y): # 训练集的拟合 X = np.insert(X, 0, 1, axis=1) # 增加一个维度 print (X.shape) X_ = np.linalg.inv(X.T.dot(X)) # 公式求解 -- X.T表示转置，X.dot(Y)表示矩阵相乘 self.w = X_.dot(X.T).dot(y) # 返回theta的值 def predict(self, X): # 测试集的测试反馈 # 为偏置权值插入常数项 X = np.insert(X, 0, 1, axis=1) # 增加一个维度 y_pred = X.dot(self.w) # 测试集与拟合的训练集相乘 return y_pred # 返回最终的预测值def mean_squared_error(y_true, y_pred): #真实数据与预测数据之间的差值（平方平均） mse = np.mean(np.power(y_true - y_pred, 2)) return msedef main(): # 第一步：导入数据 # 加载糖尿病数据集 diabetes = datasets.load_diabetes() # 只使用其中一个特征值(把一个422x10的矩阵提取其中一列变成422x1) X = diabetes.data[:, np.newaxis, 2] # np.newaxis的作用就是在原来的数组上增加一个维度。2表示提取第三列数据 print (X.shape) # 第二步：将数据分为训练集以及测试集 x_train, x_test = X[:-20], X[-20:] print(x_train.shape,x_test.shape) # (422, 1) (20, 1) # 将目标分为训练/测试集合 y_train, y_test = diabetes.target[:-20], diabetes.target[-20:] print(y_train.shape,y_test.shape) # (422,) (20,) #第三步：导入线性回归类（之前定义的） clf = LinearRegression() clf.fit(x_train, y_train) # 训练 y_pred = clf.predict(x_test) # 测试 #第四步：测试误差计算（需要引入一个函数） # 打印平均值平方误差 print (\"Mean Squared Error:\", mean_squared_error(y_test, y_pred)) # Mean Squared Error: 2548.072398725972 #matplotlib可视化输出 # Plot the results plt.scatter(x_test[:,0], y_test, color='black') # 散点输出 plt.plot(x_test[:,0], y_pred, color='blue', linewidth=3) # 预测输出 plt.show()if __name__ == '__main__': main()","categories":[{"name":"人工智能","slug":"人工智能","permalink":"https://lesama.github.io/categories/人工智能/"},{"name":"机器学习","slug":"人工智能/机器学习","permalink":"https://lesama.github.io/categories/人工智能/机器学习/"}],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"https://lesama.github.io/tags/机器学习/"},{"name":"Python","slug":"Python","permalink":"https://lesama.github.io/tags/Python/"}],"keywords":[{"name":"人工智能","slug":"人工智能","permalink":"https://lesama.github.io/categories/人工智能/"},{"name":"机器学习","slug":"人工智能/机器学习","permalink":"https://lesama.github.io/categories/人工智能/机器学习/"}]},{"title":"机器学习-线性回归-推导总结","slug":"2019-03-08-ml-linearRegressionL1L2","date":"2019-03-08T11:14:30.000Z","updated":"2019-03-10T11:24:12.358Z","comments":true,"path":"2019-03-08-ml-linearRegressionL1L2.html","link":"","permalink":"https://lesama.github.io/2019-03-08-ml-linearRegressionL1L2.html","excerpt":"","text":"线性回归-推导总结我们已经大致的知道了，线性回归的算法推导过程，但是往往我们在使用线性回归算法的过程中模型会出现过拟合的现象， 我们现从例子来看看什么是过拟合。 还是以房价预测为例，来看几张张图片： 1.欠拟合（Underfitting） 上图中，我们用$h_\\theta(x)=\\theta_0+\\theta_1x $来拟合训练集中的数据，但是我们可以很明显的从图中看出，房价是不会随着面积成比例的增长的，这种情况，我们就称之为欠拟合。 2.过拟合（Overfitting） 如上图所示，我们用一条高次的曲线 $h_θ(x)=θ_0+θ_1x+θ_2x^2+θ_3x^3+θ_4x^4$ 来拟合训练集中的数据，因为参数过多，对训练集的匹配度太高、太准确，以至于在后面的预测过程中可能会导致预测值非常偏离合适的值，预测非常不准确，也就是说能力太强了，导致震荡的非常强烈。这就是过拟合。 3.合适的拟合（Properfitting）​ 如上图，如何参数选择的恰当，选用一个合适的曲线，比如说是$h_θ(x)=θ_0+θ_1x+θ_2x^2$来拟合上面的数据集就非常适合，这样这就是一个比较恰当的假设参数（hypothesis function）. 简单总结一下一般在实际的应用中是不会遇到欠拟合的情况的，但是过拟合是经常出现的，一般情况下，过拟合（Overfitting）就是：如果我在训练一个数据集的时候，用了太多的特征（features）来训练一个假设函数，就会造成匹配度非常高（误差几乎就为0， 也就是我上一节得出的损失函数：$ J(θ)=∑_N^{i=1}(y_i−θ^Tx_i)^2$),但是不能推广到其他的未知数据上，也就是对于其他的训练集是没有任何用的，不能做出正确的预测。 所以为了避免这种过拟合现象的发生，我们也有对应得惩罚，让他的能力不要那么强，所以就有L1(LASSO)、岭回归L2(Ridge)。我们来直观的了解下这两种正则。 最小均方函数导数不为0时，L2导数加上最小均方函数导数肯定不为0。但是L1的正则项是绝对值函数，导数为0只要在x从左边趋向于0和从右边趋向于0时导数异号就行，所以更容易得到稀疏解。 目标函数最小均方差解空间为同心圆，L2解空间也为同心圆，L1解空间为菱形，两个解空间相交处为最优值。如图所示。 ​ 数学推导总结上节的知识点，我们就有三种方式解出线性回归算法的表达式或解析解： 最小二乘法的解析解可以用高斯分布（Gaussian）以及最大似然估计法求得 岭回归Ridge（L2正则）的解析解可以用高斯分布（Gaussian）以及最大后验概率解释 LASSO（L1正则）的解释解可以用拉普拉斯（Laplace）分布以及最大后验概率解释 在推导之前： 假设你已经懂得：高斯分布，拉普拉斯分布，最大似然估计，最大后验估计 机器学习的三要素：模型、策略、算法（李航《统计学习方法》）。就是说，一种模型可以有多种求解策略，每一种求解策略可能又有多种计算方法。所以先把模型策略搞懂，然后算法。 线性回归模型总结首先我们先假设线性回归模型： $f(x)= \\sum_{i=1}^nx_iw_i+b=w^TX+b​$ 其中$x \\in R^{1\\times n}, w\\in R^{1\\times n},当前已知：X=(x_1 \\cdot \\cdot \\cdot x_m) \\in R^{m\\times n}, y \\in R^{n\\times 1}, b \\in R$,求出$w$ 最小二乘法如果$b \\sim N(u, \\sigma^2)​$, 其中$u=0​$, 也就是说$y_i \\sim N(w^TX,\\sigma^2)​$ 采用最大似然估计法：$L(w)=\\prod_{i=1}^{N}\\frac{1}{\\sqrt{2\\pi}\\sigma}e^{-(\\frac{(y_i-w^Tx_i)^2}{2\\sigma^2})}$ 对数似然函数：$l(w)=-nlog\\sigma\\sqrt{2\\pi}-\\frac{1}{2\\sigma^2}\\sum_{i=1}^{n}(y_i-w^Tx_i)^2 ​$ 因为我们要求的是似然函数的最大值： $arg max_w \\ L(w)=\\prod_{i=1}^{N}\\frac{1}{\\sqrt{2\\pi}\\sigma}e^{-(\\frac{(y_i-w^Tx_i)^2}{2\\sigma^2})}​$ 通过对数似然进行变换后，因为$-nlog\\sigma\\sqrt{2\\pi}​$是定值，所以最终解析解： $arg min_w f(w)=\\frac{1}{2\\sigma^2}\\sum_{i=1}^{n}(y_i-w^Tx_i)^2 =||y-w^TX||_2^2​$ 岭回归Redge(L2正则)如果$b \\sim N(u, \\sigma^2), w_i \\sim N(u, \\tau^2)$,其中$u=0$; 所以使用最大后验估计推导： 构建似然函数： $L(w)=\\prod_{i=1}^{n}\\frac{1}{\\sqrt{2\\pi}\\sigma}e^{-(\\frac{(y_i-w^Tx_i)^2}{2\\sigma^2})} \\cdot \\prod_{j=1}^{d}\\frac{1}{\\sqrt{2\\pi}\\tau}e^{-(\\frac{(w_j)^2}{2\\tau^2})}​$ 对数似然函数 $l(w)=-nln\\sigma\\sqrt{2\\pi}-\\frac{1}{2\\sigma^2}\\sum_{i=1}^{n}(y_i-w^Tx_i)^2 -dln \\tau \\sqrt{2\\pi}-\\frac{1}{2\\tau^2}\\sum_{j=1}^{d}(w_j)^2 ​$ 因为$-nln\\sigma\\sqrt{2\\pi}-dln \\tau \\sqrt{2\\pi}$是定值，最后的解析解： $arg max_w \\ L(w) = arg min_w f(w)=\\frac{1}{2\\sigma^2}\\sum_{i=1}^{n}(y_i-w^Tx_i)^2+ \\lambda\\sum_{j=1}^{d}(w_j)^2 \\\\ =||y-w^TX||_2^2+\\lambda||w||_2^2 ​$ LASSO(L1正则)如果$b \\sim N(u, \\sigma^2), w_i \\sim Laplace(u,b)​$,其中$u=0​$; 所以使用最大后验估计推导： 构建似然函数： $L(w)=\\prod_{i=1}^{n}\\frac{1}{\\sqrt{2\\pi}\\sigma}e^{-(\\frac{(y_i-w^Tx_i)^2}{2\\sigma^2})} \\cdot \\prod_{j=1}^{d}\\frac{1}{2b}e^{-(\\frac{|w_i|}{b})}​$ 对数似然： $l(w)=-nln\\sigma\\sqrt{2\\pi}-\\frac{1}{2\\sigma^2}\\sum_{i=1}^{n}(y_i-w^Tx_i)^2 -dln 2b -\\frac{1}{b}\\sum_{j=1}^{d}|w_j| ​$ 因为$-nln\\sigma\\sqrt{2\\pi}-dln2b$是定值，最后的解析解： $arg max_w \\ L(w) = arg min_w f(w)=\\frac{1}{2\\sigma^2}\\sum_{i=1}^{n}(y_i-w^Tx_i)^2+ \\lambda\\sum_{j=1}^{d}|w_j| \\\\ =||y-w^TX||_2^2+\\lambda||w||_1$ 线性回归正则化总结L1正则化和L2正则化可以看做是损失函数的惩罚项，所谓『惩罚』是指对损失函数中的某些参数做一些限制 ，都能防止过拟合，一般L2的效果更好一些，L1能够产生稀疏模型，能够帮助我们去除某些特征，因此可以用于特征选择。 L2正则化可以防止模型过拟合（overfitting）；一定程度上，L1也可以防止过拟合 L1正则化可以产生稀疏权值矩阵，即产生一个稀疏模型，可以用于特征选择","categories":[{"name":"人工智能","slug":"人工智能","permalink":"https://lesama.github.io/categories/人工智能/"},{"name":"机器学习","slug":"人工智能/机器学习","permalink":"https://lesama.github.io/categories/人工智能/机器学习/"}],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"https://lesama.github.io/tags/机器学习/"}],"keywords":[{"name":"人工智能","slug":"人工智能","permalink":"https://lesama.github.io/categories/人工智能/"},{"name":"机器学习","slug":"人工智能/机器学习","permalink":"https://lesama.github.io/categories/人工智能/机器学习/"}]},{"title":"机器学习-线性回归-数学推导","slug":"2019-03-07-ml-linearRegression","date":"2019-03-07T11:14:30.000Z","updated":"2019-03-10T11:20:53.187Z","comments":true,"path":"2019-03-07-ml-linearRegression.html","link":"","permalink":"https://lesama.github.io/2019-03-07-ml-linearRegression.html","excerpt":"","text":"线性回归-$y=wx+b$回归，统计学术语，表示变量之间的某种数量依存关系，并由此引出回归方程，回归系数。 线性回归（Linear Regression）数理统计中回归分析，用来确定两种或两种以上变量间相互依赖的定量关系的一种统计分析方法，其表达形式为$y = wx+e$，$e$为误差服从均值为0的正态分布，其中只有一个自变量的情况称为简单回归，多个自变量的情况叫多元回归。 注意，统计学中的回归并如线性回归非与严格直线函数完全能拟合，所以我们统计中称之为回归用以与其直线函数区别。 我们先来看下这个表格 姓名 工资（元） 房屋面积（平方） 可贷款金额（元） 张三 6000 58 30000 李四 9000 77 55010 王五 11000 89 73542 这个是近期比较火的现金贷产品的贷款额度。这个表格表示的是可贷款的金额 与 工资 和 房屋面积之间的关系，其中 工资 和 房屋面积 为 特征，可贷款金额为目标函数值。 那么根据线性函数可得到以下公式。 $h_\\theta(x)=\\theta_{1}x_{1}+\\theta_{2}x_{2}$ 上面的这个式子是当一个模型只有两个特征$(x_1,x_2)$的时候的线性回归式子。 正常情况下，现金贷中可贷款的额度和用户的很多特征相关联，并不只是简单的这两个特征。所以我们需要把这个式子进行通用化。 假如有n个特征的话，那么式子就会变成下面的样子 $h_\\theta(x)=\\theta_{1}x_{1}+\\theta_{2}x_{2} + \\cdot \\cdot \\cdot \\cdot \\cdot+\\theta_{n}x_{n} = \\sum_{i=1}^{n}\\theta_{i}x_{i}​$ 利用矩阵的知识对线性公式进行整合 因为机器学习中基本上都是用矩阵的方式来表示参数的，也就是说我们需要把这个多项求和的式子用矩阵的方式表达出来，这样才方便后续的计算。 $\\theta_{i \\times 1} = [\\theta_1,\\theta_2,\\cdot\\cdot\\cdot\\theta_i,]$ $X_{i\\times1}=[x_1,x_2,\\cdot \\cdot \\cdot x_i]$ 把上述线性函数写成矩阵相乘的形式 $\\theta^TX=\\begin{bmatrix} \\theta_1 \\\\ \\theta_2 \\\\ \\cdot \\\\ \\cdot \\\\ \\cdot \\\\ \\theta_i \\end{bmatrix} \\cdot [x_1,x_2,\\cdot \\cdot \\cdot x_i] = \\sum_{i=1}^{n}\\theta_{i}x_{i}​$我们把权重参数和特征参数，都看成是1行n列的矩阵(或者是行向量)。那么就可以根据矩阵乘法的相关知识，把上述多项求和的式子，转换成矩阵的乘法的表达式。 由此我们就把多项求和化简称了 。 $h_\\theta(x)=\\theta^TX​$ 误差项的分析原式:$y =wx+b$ 其中$b$就是我们所说的偏移量，或者叫误差项。 我们再看看下面这个图： 图中的横坐标$x_1$ 和 X$x)_2$分别代表着 两个特征(工资、房屋平米) 。纵坐标Y代表目标(可贷款的额度)。其中红点代表的就是实际的目标值(每个人可贷款的额度).而平面上和红点竖向相交的点代表着我们根据线性回归模型得到的点。也就是说实际得到的钱和预估的钱之间是有一定误差的，这个就是误差项。 因为误差项是真实值和误差值之间的一个差距。那么肯定我们希望误差项越小越好。 然后我们对应整理成线性回归函数： $h_\\theta(x)=\\theta^Tx+\\varepsilon​$ 我们根据实际情况，假设认为这个误差项是满足以下几个条件的。 误差$\\varepsilon_{(i)}​$是独立。 具有相同的分布。 服从均值为0方差为$\\theta^2$的高斯分布。 然我们回到刚开始的现金贷产品的贷款额度问题上面 1.独立：张三和李四一起使用这款产品，可贷款额互不影响 2.同分布：张三和李四是使用的是同一款产品 3.高斯分布：绝大多数的情况下，在一个的空间内浮动不大 似然函数的理解由前面两步，我们已经把线性回归模型，推导成下面的这个式子了 $y_{(i)}=\\theta^Tx_i+\\varepsilon_i$ 我们已经知道误差项是符合高斯分布的，所以误差项的概率值： $P(\\varepsilon_i)=\\frac{1}{\\sqrt{2\\pi}\\sigma}e^{-(\\frac{(\\varepsilon_i)^2}{2\\sigma^2})}$然后把误差值带入式子中: $P(y_i|x_i,\\theta)=\\frac{1}{\\sqrt{2\\pi}\\sigma}e^{-(\\frac{(y_i-\\theta^Tx_i)^2}{2\\sigma^2})}​$由于是误差值，所以是越小越好，所以我们接下来就是讨论什么样的特征值和特征组合能够让误差值最小，现在就要看似然函数的作用了，似然函数的作用就是要根据样本求什么样的参数和特征的组成能够接近真实值，所以越接近真实值则误差就越小。 引入似然函数(似然函数就是求能让真实值和预测值相等的那个参数的 )： $L(\\theta) = \\prod_{i=1}^{N} P(y_i|x_i,\\theta)=\\prod_{i=1}^{N}\\frac{1}{\\sqrt{2\\pi}\\sigma}e^{-(\\frac{(y_i-\\theta^Tx_i)^2}{2\\sigma^2})}$ $\\prod​$表示各元素相乘的结果 上面的式子是多个参数的乘积的形式，很难进行计算，所以我们又采用了对数的一个小技巧，把多个数相乘，转化成多个数相加的形式。 因为对数的性质 1logA\\cdot B = logA+logB​ 根据上面的这种换算关系，我们就把似然函数的式子换算成下面的这个。 (因为似然函数是越大越好，似然函数的值和对数似然函数的值是成正比的，对值求对数，并不会影响到最后求极限的值。所以才敢进行对数处理。) $l(\\theta) = logL(\\theta) = log\\prod_{i=1}^{N}\\frac{1}{\\sqrt{2\\pi}\\sigma}e^{-(\\frac{(y_i-\\theta^Tx_i)^2}{2\\sigma^2})}​$对上式进行整理： $l(\\theta) = logL(\\theta) = \\sum_{i=1}^{N}log\\frac{1}{\\sqrt{2\\pi}\\sigma}e^{-(\\frac{(y_i-\\theta^Tx_i)^2}{2\\sigma^2})}$ $= \\sum_{i=1}^{N}(log\\frac{1}{\\sqrt{2\\pi}\\sigma}+loge^{-(\\frac{(y_i-\\theta^Tx_i)^2}{2\\sigma^2})})​$ $= Nlog\\frac{1}{\\sqrt{2\\pi}\\sigma}-\\frac{1}{2\\sigma^2}\\sum_{i=1}^{N}(y_i-\\theta^Tx_i)^2 $ 因为： $Nlog\\frac{1}{\\sqrt{2\\pi}\\sigma}​$ 是一个定值 似然函数是要越大越好 所以： $-\\frac{1}{2\\sigma^2}(y_i-\\theta^Tx_i)^2$越小越好 再因为： $-\\frac{1}{2\\sigma^2}​$也为定值 最终： $l(\\theta) = \\sum_{i=1}^{N}(y_i-\\theta^Tx_i)^2​$ 越小越好——最小二乘法（损失函数）最小二乘法$\\sum_{i=1}^{N}(y_i-\\theta^Tx_i)^2$ 上述代价函数中使用的均方误差，其实对应了我们常用的欧几里得的距离（欧式距离，Euclidean Distance）, 基于均方误差最小化进行模型求解的方法称为“最小二乘法”（least square method），即通过最小化误差的平方和寻找数据的最佳函数匹配； 当函数子变量为一维时，最小二乘法就蜕变成寻找一条直线； 然后我们把得到的损失函数推广到n维，转换成矩阵形式（参考前面利用矩阵的知识对线性公式进行整合）： $J(\\theta)=\\sum_{i=1}^{N}(y_i-\\theta^Tx_i)^2​$ 为损失函数 其对应的均方误差表示为如下矩阵 $J(\\theta) = {(y-X\\theta)^T(y-X\\theta)}​$ 其中X： $X=\\begin{bmatrix} 1 &amp;&amp; x_1^T \\\\ 1 &amp;&amp; x_2^T \\\\ \\cdot \\\\ \\cdot \\\\ \\cdot \\\\ 1 &amp;&amp; x_N^T \\end{bmatrix} =\\begin{bmatrix} 1 &amp;&amp; x_{11} &amp;&amp; x_{12} &amp;&amp; \\cdot \\cdot \\cdot x_{1n} \\\\ 1 &amp;&amp; x_{21} &amp;&amp; x_{22} &amp;&amp; \\cdot \\cdot \\cdot x_{2n} \\\\ \\cdot \\\\ \\cdot \\\\ \\cdot \\\\ 1&amp;&amp; x_{m1} &amp;&amp; x_{m2} &amp;&amp; \\cdot \\cdot \\cdot x_{mn} \\end{bmatrix} ​$ 对$\\theta​$求导 $J(\\theta) = {(y-X\\theta)^T(y-X\\theta)}=y^Ty-y^Tx\\theta-\\theta^Tx^Ty+\\theta^Tx^Tx\\theta​$ $\\frac{\\partial J(\\theta)}{\\partial(\\theta)} = \\frac{\\partial y^Ty}{\\partial(\\theta)} - \\frac{\\partial y^Tx\\theta}{\\partial(\\theta)} - \\frac{\\partial \\theta^Tx^Ty}{\\partial(\\theta)} + \\frac{\\partial \\theta^Tx^Tx\\theta}{\\partial(\\theta)} ​$ $\\frac{\\partial J(\\theta)}{\\partial(\\theta)} = 0-x^Ty-x^Ty+2x^Tx\\theta​$ $\\frac{\\partial J(\\theta)}{\\partial(\\theta)} =2x^T(x\\theta-y)​$ 根据导数的性质，该值在导数为0时为最小 所以：根据微积分定理，令上式等于零，可以得到 θ 最优的闭式解。当 $2(x^Ty-x^Tx\\theta)=0$时取得最小 矩阵求导的知识： 最终：$\\theta = (x^Tx)^{-1}x^Ty​$ X和Y都是已知的，那么得到了最终的参数值。 我们来看看数学原理微积分角度来讲，最小二乘法是采用非迭代法，针对代价函数求导数而得出全局极值，进而对所给定参数进行估算。 计算数学角度来讲，最小二乘法的本质上是一个线性优化问题，试图找到一个最优解。 线性代数角度来讲，最小二乘法是求解线性方程组，当方程个数大于未知量个数，其方程本身 无解，而最小二乘法则试图找到最优残差。 几何角度来讲，最小二乘法中的几何意义是高维空间中的一个向量在低维子空间的投影。 概率论角度来讲，如果数据的观测误差是/或者满足高斯分布，则最小二乘解就是使得观测数据出现概率最大的解，即最大似然估计-Maximum Likelihood Estimate，MLE（利用已知的样本结果，反推最有可能（最大概率）导致这样结果的参数值）。","categories":[{"name":"人工智能","slug":"人工智能","permalink":"https://lesama.github.io/categories/人工智能/"},{"name":"机器学习","slug":"人工智能/机器学习","permalink":"https://lesama.github.io/categories/人工智能/机器学习/"}],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"https://lesama.github.io/tags/机器学习/"}],"keywords":[{"name":"人工智能","slug":"人工智能","permalink":"https://lesama.github.io/categories/人工智能/"},{"name":"机器学习","slug":"人工智能/机器学习","permalink":"https://lesama.github.io/categories/人工智能/机器学习/"}]},{"title":"数值类型与序列类型","slug":"python-numerical-sequence","date":"2019-02-25T13:40:51.000Z","updated":"2019-03-07T12:30:32.558Z","comments":true,"path":"python-numerical-sequence.html","link":"","permalink":"https://lesama.github.io/python-numerical-sequence.html","excerpt":"","text":"1. 数值类型1.1 int（整型）整型也就是我们日常中的整数，在Python中不需要声明变量，直接赋值即可 12a = 100print(type(a)) 1.2 float（浮点型）基本情况浮点型一般是我们常见的小数 12b = 2.2print(type(b)) decimal库但是浮点数不是我们真正看到的数，比如1.2实际是1.1999999999 所以小数计算都是不精确的，那么我们如何进行精确计算呢？ 在Python中如果我们要实现精确计算，我们是使用decimal这个库函数 123456import decimal a = decimal.Decimal('2.2')b = decimal.Decimal('2')print(a-b) 基本整数与小数四则运算计算机在计算的时候，除了整数运算，还有小数运算，还有小数和整数的混合运算 运算符 描述 实例 + 加 3 + 4 输出 7 - 减 8 - 6 输出 2 * 乘 3 * 4 输出 12 / 除 6 / 3 输出 2.0 // 向下取整 9 // 2 输出结果 4 , 9.0//2.0 输出结果 4.0 % 取余 6 % 4 输出 2 ** 幂 2 ** 3 输出 8 向上取整：使用math库函数 12import mathmath.ceil(2.3/2) # 2 ​ 1.3 bool（布尔类型）布尔类型只有True和False两种值 ，在数值计算中，True表示1，False表示0。 1.4 complex （复数）复数由实数部分和虚数部分构成，可以用a + bj,或者complex(a,b)表示， 复数的实部a和虚部b都是浮点型。 12345c = 5 + 6jd = complex(5,6)print(type(c))print(type(d)) 2. 序列类型​ 2.1 字符串（str）​ 字符串的表示形式​ 在Python3中字符串有3中表示方式，如下 a. 使用单引号（’） 12st1 = 'hello world'print(st1) b. 使用双引号（”） 12st2 = \"hello world\" #双引号中的字符串与单引号中的字符串用法完全相同print(st2) c. 使用三引号（’’’） 123st2 = '''helloworld''' #三引号可表示多行的字符串，可以在三引号中自由的使用单引号和双引号print(st2) ​ 字符串的使用字符串的截取，语法格式如下 1变量[头下标:尾下标] #索引值以 0 为开始值，-1 为从末尾的开始位置。 实例如下 123456789st2 = &apos;Runoob&apos; print (st2) # 输出字符串print (st2[0:-1]) # 输出第一个到倒数第二个的所有字符print (st2[0]) # 输出字符串第一个字符print (st2[2:5]) # 输出从第三个开始到第五个的字符print (st2[2:]) # 输出从第三个开始的后的所有字符print (st2 * 2) # 输出字符串两次print (st2 + &quot;TEST&quot;) # 连接字符串 ​ Python 使用反斜杠\\转义特殊字符，如果你不想让反斜杠发生转义，可以在字符串前面添加一个 r，表示原始字符串： 12345print('楽\\no')#输出：楽# oobprint(r'楽\\no')#输出：楽\\no 另外，反斜杠\\可以作为续行符，表示下一行是上一行的延续。也可以使用 “””…””” 或者 ‘’’…’’’ 跨越多行。 总结： 反斜杠可以用来转义，使用r可以让反斜杠不发生转义。 字符串可以用+运算符连接在一起，用*运算符重复。 Python中的字符串有两种索引方式，从左往右以0开始，从右往左以-1开始。 Python中的字符串不能改变 。 ​ 2.2 列表（list）​ 列表可以完成大多数集合类的数据结构实现。列表中元素的类型可以不相同，它支持数字，字符串甚至可以包含列表（所谓嵌套）。 列表是写在方括号[] 之间,用逗号分隔开的元素列表。 12list0 = [1,'a',[2]]print(type(list0)) ​ 和字符串一样，列表同样可以被索引和截取，列表被截取后返回一个包含所需元素的新列表。 123456789list1 = ['abcd',786,2.23,'楽',70.2 ]list2 = [123, '楽'] print (list1) # 输出完整列表print (list1[0]) # 输出列表第一个元素print (list1[1:3]) # 从第二个开始输出到第三个元素print (list1[2:]) # 输出从第三个元素开始的所有元素print (list2 * 2) # 输出两次列表print (list1 + list2) # 连接列表 与Python字符串不一样的是，列表中的元素是可以改变的 12345678a = [1, 2, 3, 4, 5, 6]a[0] = 9a[2:5] = [13, 14, 15]print(a) #[9, 2, 13, 14, 15, 6]a[2:5] = [] # 将对应的元素值设置为 [] print(a) #[9, 2, 6] 总结： List写在方括号之间，元素用逗号隔开。 和字符串一样，list可以被索引和切片。 List可以使用+操作符进行拼接。 List中的元素是可以改变的。 ​ 2.3 元组​ 元组（tuple）与列表类似，不同之处在于元组的元素不能修改。元组写在小括号 ()里，元素之间用逗号隔开。 123456789tup = ( 'abcd', 786 , 2.23, '楽', 70.2 )tinytup = (123, '楽') print (tup) # 输出完整元组print (tup[0]) # 输出元组的第一个元素print (tup[1:3]) # 输出从第二个元素开始到第三个元素print (tup[2:]) # 输出从第三个元素开始的所有元素print (tinytup * 2) # 输出两次元组print (tup + tinytup) # 连接元组 元组与字符串类似，可以被索引且下标索引从0开始，-1 为从末尾开始的位置。也可以进行截取。 虽然tuple的元素不可改变，但它可以包含可变的对象，比如list列表。 构造包含 0 个或 1 个元素的元组比较特殊，所以有一些额外的语法规则： 12tup1 = () # 空元组tup2 = (20,) # 一个元素，需要在元素后添加逗号 总结： 与字符串一样，元组的元素不能修改。 元组也可以被索引和切片，方法一样。 注意构造包含 0 或 1 个元素的元组的特殊语法规则。 元组也可以使用+操作符进行拼接。 ​ 3. 扩展 类型转换字符串转列表 123456a = 'abcd'b = list(a)print(type(a))print(type(b))print(b) #['a', 'b', 'c', 'd'] 列表转字符串 123456a = ['a', 'b', 'c', 'd']b = str(a)print(type(a))print(type(b))print(b) #\"['a', 'b', 'c', 'd']\" 字符串转元组 123456a = 'abcd'b = tuple(a)print(type(a))print(type(b))print(b) #('a', 'b', 'c', 'd') ​ 元组转字符串 123456a = ('a', 'b', 'c', 'd')b = str(a)print(type(a))print(type(b))print(b) #\"('a', 'b', 'c', 'd')\" ​ 拆包​ 元组拆包可以应用到任何迭代对象上， 唯一的要求是， 被可迭代对象中的元素数量必须要和这些元素的元组的空档数一致， 除非我们用*来表示忽略多余的元素。 123456a = ('a', 'b', 'c', 'd')x,*y,z = aprint(x) #'a'print(z) #'d'print(y) #['b', 'c'] x 接收第一个元素，z 接收最后一个元素，由于y前面有*号，所以剩余的元素由y接收 总结：有多少个元素就需要多少个变量来接收，除非有*号，不然就会报错. ​ 变量赋值​ 变量的保存都是保存在内存中 注意：变量是没有类型的，有类型的是他所指向的数据 12345678910 a = 123b = 'abc'print（id(a)） # 10923232print(id(b)) # 140343125492152#id()：查看数据的地址a = '111'print（id(a)） # 140342939172344 赋值给变量是保存在内存中，重新赋值后，变量指向新的地址 ​ 变量的引用-成员运算​ 通过in或者not in 来进行成员运算 123456a = 'abcd123'print('c' in a) #Trueprint('8' in a) #Falseprint('a' not in a) #Falseprint('q' not in a) #True","categories":[{"name":"Python","slug":"Python","permalink":"https://lesama.github.io/categories/Python/"}],"tags":[{"name":"Python基础","slug":"Python基础","permalink":"https://lesama.github.io/tags/Python基础/"},{"name":"数据类型","slug":"数据类型","permalink":"https://lesama.github.io/tags/数据类型/"}],"keywords":[{"name":"Python","slug":"Python","permalink":"https://lesama.github.io/categories/Python/"}]},{"title":"JQuery","slug":"JQuery","date":"2019-02-16T09:08:18.000Z","updated":"2019-03-07T12:30:38.549Z","comments":true,"path":"JQuery.html","link":"","permalink":"https://lesama.github.io/JQuery.html","excerpt":"","text":"1. JQ简介1.1 什么是JQ​ JQ是JS写的插件库，说白了，就是一个js文件 1.2 JS和JQ是区别​ 凡是用jq能实现的，js都能实现，js能实现的，jq却不一定能实现 1.3 JQ的理念​ 减少代码量，提高工作效率 1.4 JQ的引入1.4.1 本地文件引入1&lt;script src=\"js/jquery-3.2.1.js\"&gt;&lt;/script&gt; 1.4.2 CDN引入1&lt;script src=\"https://cdn.bootcss.com/jquery/3.3.1/jquery.js\"&gt;&lt;/script&gt; 相应网站：https://www.bootcdn.cn/jquery/ 2. JQ的基本使用在JavaScript中，用$声明使用的是jQuery,例如： 1234567&lt;button class=\"btn\"&gt;点我&lt;/button&gt;&lt;script src=\"https://cdn.bootcss.com/jquery/3.3.1/jquery.js\"&gt;&lt;/script&gt;&lt;script&gt; $('button').click(function()&#123; alert(123);//点击button时弹出123 &#125;)&lt;/script&gt; 2.1 JQ的选择器在jQ中使用选择器选择元素和在CSS中使用CSS选择器是一样的 ，上面那个例子： 123456789&lt;script&gt; $('button').click(function()&#123;//使用的是标签选择器 alert(123); &#125;) $('#btn').click(function()&#123;//使用的是类选择器 alert(123); &#125;)&lt;/script&gt; 当然在使用过程中也可以用后代选择器，兄弟选择器之类的选择器 2.2 基本使用1我们首先看下面代码，方便后面讲解 123456789101112131415161718&lt;div id=\"div1\"&gt; &lt;p id=\"p1\" class=\"p11\"&gt;我是段落标签一&lt;/p&gt; &lt;p id=\"p2\" class=\"p11\"&gt;我是段落标签二&lt;/p&gt; &lt;p id=\"p3\" class=\"p11\"&gt;我是段落标签三&lt;/p&gt; &lt;span&gt;我是文本标签一&lt;/span&gt; &lt;span&gt;我是文本标签二&lt;/span&gt; &lt;ul&gt; &lt;li&gt;0&lt;/li&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;li&gt;4&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;&lt;script&gt; var p1 = document.getElementById(\"p1\"); $(\"#p1\");&lt;/script&gt; 2.2.1 JS与JQ之间的转换(1) jq转js：get()与[]12$(\"p\").get(2).innerText = '1111111';$(\"p\")[1].innerText = '222222'; get()与[]中填写索引值，然后对其进行操作。 (2) js转jq用$()将js定义的变量括起来，如： 1$(p1) //js转jq html()1$(p1).html(123123); //html等同于js的innerHtml text()1$(p1).text(123123); //text等同于js的innerText 2.2.2 鼠标事件(1) 单击：click()123$(&quot;#p1&quot;).click(function () &#123; alert(123) &#125;); (2) 鼠标移入移出12345$(\"#p1\").hover(function () &#123; $(\"#p2\").html(\"鼠标移入效果\") //鼠标移入 &#125;,function () &#123; $(\"#p2\").html(\"鼠标移出效果\") //鼠标移出 &#125;); 2.2.3 追加与添加12$(\"#p1\").append(\"&lt;p&gt;我是p1的兄弟&lt;/p&gt;\"); //将双引号内的内容追加到#p1后面$(\"#p1\").prepend(\"&lt;p&gt;我也是p1的兄弟&lt;/p&gt;\"); //将双引号内的内容添加到#p1前面 2.2.4 遍历：each1234$(\"ul li\").each(function (i) &#123; $(this).html(\"我是第\"+i+\"个\") //this是指遍历的当前的对象自己 alert($(this).index()); //弹出遍历的当前的对象的索引值 &#125;); 2.2.5 操作属性12$(\"#div1\").attr(\"class\",\"b\"); //添加类属性，类名为b$(\"#div1\").removeAttr(\"class\") //删除属性class 2.2.6 操作class类名12$(\"#div1\").addClass(\"div321\"); //添加类名$(\"#div1\").removeClass(); //删除类名 2.2.7 判断属性1alert($(\"#div1\").hasClass(\"div222\")); //判断div1中是否存在类名为div222 2.2.8 滚动条事件1234$(window).scroll(function () &#123; console.log($(document).scrollTop()); //打印滚动条与顶部的距离 console.log($(document).scrollLeft()) //打印滚动条与左边的距离&#125;) 2.2.9 查找元素12345console.log($(\"#div1\").parent()); //查找父级元素bodyconsole.log($(\"#div1\").children()); //查找子级元素console.log($(\"#p1\").siblings()); //查找兄弟元素console.log($(\"#div1\").find(\"span\")); //查找后代元素console.log($(\"#sp1\").parents(\"p\")); //查找祖辈元素","categories":[{"name":"web","slug":"web","permalink":"https://lesama.github.io/categories/web/"}],"tags":[{"name":"jq","slug":"jq","permalink":"https://lesama.github.io/tags/jq/"},{"name":"html","slug":"html","permalink":"https://lesama.github.io/tags/html/"},{"name":"web","slug":"web","permalink":"https://lesama.github.io/tags/web/"},{"name":"网页","slug":"网页","permalink":"https://lesama.github.io/tags/网页/"}],"keywords":[{"name":"web","slug":"web","permalink":"https://lesama.github.io/categories/web/"}]},{"title":"JavaScript-03","slug":"JavaScript-03","date":"2019-02-11T13:46:30.000Z","updated":"2019-03-07T12:30:44.351Z","comments":true,"path":"JavaScript-03.html","link":"","permalink":"https://lesama.github.io/JavaScript-03.html","excerpt":"","text":"Math方法 sqrt：开方 abs：绝对值 PI：π pow(x,y) ：x的y次方 round：取整（四舍五入） random：随机数0~1 min（x，y，z）：从x，y，z中取最小值 max（x，y，z）：从x，y，z中取最大值 ceil：向上取整 floor：向下取整 例： 1Math.round(Math.random*100) //随机生成1~100的随机数 日期对象Date方法new Date()：新建日期对象 getFullYear：获取年份 getMonth：获取月份 getDay：获取日 getHours：获取时 getMinutes：获取分 getSeconds：获取秒 例： 12345678var today = new Date();var year = today.getFullYear();var month = today.getMonth()+1;var day = today.getDay();var hour = today.getHours();var minute = today.getMinutes(); var second = today.getSeconds();console.log(year+&apos;年&apos;+month+&apos;月&apos;+day+&apos;日&apos;+hour+&apos;:&apos;+minute+&apos;:&apos;+second); 时间戳时间戳：格林威治时间1970年01月01日00时00分00秒(北京时间1970年01月01日08时00分00秒)起至现在的总秒数。 123var timestamp = Date.new();//新建console.log(&quot;timestamp:&quot;timestamp); 函数函数的定义函数是通常是把一系列重复使用的操作封装成一个方法，方便调用 函数分类：有名函数，匿名函数 定义有名函数:1234function 函数名()&#123; //代码块 console.log(&quot;OK&quot;)&#125; 自定义函数： 123var result=function 函数名()&#123; //代码块&#125; 调用函数1函数名(); 匿名函数：​ 匿名函数一般充当事件函数 例： 1234567var box = document.getElementById(&apos;box&apos;);box.onclick = function()&#123; console.log(123);&#125;; 自调用函数：自调用函数是在函数表达式写完后自动执行 其函数表达式前面加上 (,),+,-,!,~ 例： 1234567(function()&#123; console.log(&quot;ok&quot;);&#125;)();+function()&#123; console.log(&quot;ok&quot;);&#125;(); 函数参数： 12345function sum()&#123; var a = x+y+z； //需要传入3个参数x，y，z console.log(argments); //argments为接收的不定参数 console.log(a)&#125; 定时器 setTimeout：设置定时器 clearTimeout：清除定时器 setInterval：设置定时器 clearInterval：清除定时器 注：清除定时器的时候，要给定时器加个名字 例： 12345678910111213141516var btn = document.getElementsByTagName(&quot;button&quot;)[0]; //1000毫秒=1秒setTimeout(function () &#123; console.log(123) &#125;,1000);var timer = setInterval(function () &#123; console.log(123)&#125;,1000);btn.onclick = function () &#123; clearInterval(timer);&#125;; setTimeout与setInterval的区别 setTimeout执行一次，setInterval一直循环执行，直到清除定时器","categories":[{"name":"web","slug":"web","permalink":"https://lesama.github.io/categories/web/"}],"tags":[{"name":"web","slug":"web","permalink":"https://lesama.github.io/tags/web/"},{"name":"网页","slug":"网页","permalink":"https://lesama.github.io/tags/网页/"},{"name":"js","slug":"js","permalink":"https://lesama.github.io/tags/js/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://lesama.github.io/tags/JavaScript/"}],"keywords":[{"name":"web","slug":"web","permalink":"https://lesama.github.io/categories/web/"}]},{"title":"JavaScript-02","slug":"JavaScript-02","date":"2019-02-08T16:06:35.000Z","updated":"2019-03-07T12:30:49.659Z","comments":true,"path":"JavaScript-02.html","link":"","permalink":"https://lesama.github.io/JavaScript-02.html","excerpt":"","text":"JavaScript操作符运算符 关系运算符 &gt; &lt; &gt;= &lt;= != == === !== ​ ==:比较数据 不比较类型 ​ ===：比数据比类型 . 逻辑运算符 &amp;&amp;逻辑与 || 逻辑或 ！逻辑非 算术运算符 + － / % ++ －－ += = /= 赋值运算符 = 条件运算符 （三目运算符 三元运算符）？： 操作符typeof判断变量的数据类型 两种写法 typeof 变量名 typeof （变量名） number –如果这个字值是数值 string –如果这个字值是字符串 undefined –如果这个字值是未定义 boolean –如果这个字值是布尔值 object –如果这个字值是对象或null function –如果这个字值是函数 JavaScript控制流程语句 选择结构 ​ if…else ​ switch…case(可以使用字符串) 循环结构 ​ for ​ do…while ​ while ​ for in for(var i in 数组名) i 代表数组下标，只能放在数组中 跳转语句 ​ break ​ continue 常用方法字符串的常用方法 lenght; 长度 []/get（）;下标 Replace（）;替换 Split（）; 分割 Slice（）;切割 Substring（）;截取 toUpperCase（）;转大写 toLowerCase（）;转小写 isnan（）;–判断是否为数值类型 –true 不是数值 –false 是数值 parseint（）; 转数值类型 parsefloat（）; 转小数类型 字符串函数 ​ indexof（””） ​ 字符串.indexof（”a”）; –返回a字符 在字符串中的下标 从0开始，如果未找到返回-1 数组的常用方法 length;长度 [];下标 push（）;右加 Unshift（）;左家 Pop（）;右删 Shift（）;左删 Concat（）;连接 Reverse（）;反向 Sort（）;排序 join（）;拼接 splice（）;替换 slice（）;切片 indexOf（）;索引","categories":[{"name":"web","slug":"web","permalink":"https://lesama.github.io/categories/web/"}],"tags":[{"name":"web","slug":"web","permalink":"https://lesama.github.io/tags/web/"},{"name":"网页","slug":"网页","permalink":"https://lesama.github.io/tags/网页/"},{"name":"js","slug":"js","permalink":"https://lesama.github.io/tags/js/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://lesama.github.io/tags/JavaScript/"}],"keywords":[{"name":"web","slug":"web","permalink":"https://lesama.github.io/categories/web/"}]},{"title":"JavaScript-01","slug":"JavaScript-01","date":"2019-01-22T01:30:04.000Z","updated":"2019-03-07T12:30:55.813Z","comments":true,"path":"JavaScript-01.html","link":"","permalink":"https://lesama.github.io/JavaScript-01.html","excerpt":"","text":"1. 简介 javaScript简称 — js 网页三剑客： ​ html、css、js JavaScript简介： 1995年由 netspace和sun合作制作 一种基于对象（object）和事件驱动并具有相对安全性的客户端脚本语言 特点 是一种可以和html标记语言混合使用的脚本语言，不能单独运行 ECMA（欧洲计算机商协会）的标准，支持大部分浏览器 注意事项 严格区分大小写 每一行完整的语句后都要加分号 变量名不能使用关键字 代码要注意缩进，保持代码可读性 2. 如何使用JavaScript1234567891011121314151617181920212223242526272829&lt;html&gt;``` &lt;head&gt;&lt;/head&gt; &lt;body&gt;&lt;/body&gt;```&lt;/html&gt;```1.嵌套 一般放在head中&lt;script type=\"text/javascript\"&gt; //代码&lt;/script&gt;2.引用外部js文件&lt;script type=\"text/javascript\" src=\"js文件地址\"&gt;&lt;/script&gt;3.行级&lt;button onclick=\"javascript:alert('123')\"&gt;按钮&lt;/button&gt;``` 获取元素 getElementById id-通过ID获取元素 getElementsByClassName class-通过class名字获取 getElementsByTagName tagName-通过标签名获取元素 getElementsByName name-通过属性名获取元素，一般用于input selector-通过CSS选择器获取一个 selectorAll-通过CSS选择器获取所有 简单事件鼠标事件： onclick –单击事件 ondbclick –双击事件 onmouseenter –鼠标划入 onmouseleave –鼠标划出 onresize –窗口变化 onchange –改变下拉框 数据类型数据类型（6种 5种简单数据类型，一种复杂数据类型）弱类型弱类型 number 数值型 不区分整数和浮点数，没有限制长度 string 字符串 undefined 未定义 专门用来确定一个变量是否有初始值 . null 空 用于表明某个变量的值为空 boolean 布尔型 还有一种复杂性数据类型 object 对象 属性操作 - 合法属性及自定义属性(增删改查) 变量名.classname=’box’; 增（无则增有则改） console.log(变量名.className); 查 变量名.reremoveAttribute(‘属性名’) 删 classname/removeAttribute setAttribute 增加效果（无则增有则改） hasAttritube 查找 removeAttribute 删除效果","categories":[{"name":"web","slug":"web","permalink":"https://lesama.github.io/categories/web/"}],"tags":[{"name":"web","slug":"web","permalink":"https://lesama.github.io/tags/web/"},{"name":"网页","slug":"网页","permalink":"https://lesama.github.io/tags/网页/"},{"name":"js","slug":"js","permalink":"https://lesama.github.io/tags/js/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://lesama.github.io/tags/JavaScript/"}],"keywords":[{"name":"web","slug":"web","permalink":"https://lesama.github.io/categories/web/"}]},{"title":"CSS进阶","slug":"css-02","date":"2019-01-19T06:25:00.000Z","updated":"2019-03-07T12:31:07.966Z","comments":true,"path":"css-02.html","link":"","permalink":"https://lesama.github.io/css-02.html","excerpt":"","text":"1. 盒子模型可以把页面上的元素看成一个盒子 盒子模型由内容、内边距、边框、外边距构成 padding - 内边距 margin - 外边距 ☆ border - 边框 content(width、height) - 内容 border-top: 上边框 border-right: 右边框 border-left: 左边框 border-bottom: 下边框 double 双线 dotted 点 dashed 虚线 solid 实线 padding、margin - 参数 上右下左 顺时针 px 像素 2. Reset 重置Reset - 重置CSS 浏览器解析标签的时候本身自带一些样式，有时会导致我们自身写的样式出现的效果不一致 每个公司会根据自己的业务需求写一套属于自己的ResetCss 以下是一个通用的RESETCSS： https://meyerweb.com/eric/tools/css/reset/ 3. 浮动float:left 向左浮动 float:right 向右浮动 使用浮动须知： - 要先改成内联块状 - 脱离文档流 - 可能会造成高度塌陷 三种解决方法： 1、overflow:hidden;不推荐只适用于纯浮动的页面布局 2、加一个空的&lt;div&gt;&lt;/div&gt;;也不推荐 3、.clearfix::{ display:block; clear:both; content:&apos;&apos;; 空字符 } 推荐 比较常用 4. 定位作用：对元素进行精确的定位 三种形式 1、绝对定位:position:absolute; 绝对定位是脱离文档流的 2、相对定位:posttion:relative; 3、固定定位:position:fixed; 固定定位与相对定位不脱离文档流，是相对于自己的一个偏移 父相（对）子绝（对）：保持页面的布局完整","categories":[{"name":"web","slug":"web","permalink":"https://lesama.github.io/categories/web/"}],"tags":[{"name":"html","slug":"html","permalink":"https://lesama.github.io/tags/html/"},{"name":"web","slug":"web","permalink":"https://lesama.github.io/tags/web/"},{"name":"网页","slug":"网页","permalink":"https://lesama.github.io/tags/网页/"},{"name":"css","slug":"css","permalink":"https://lesama.github.io/tags/css/"}],"keywords":[{"name":"web","slug":"web","permalink":"https://lesama.github.io/categories/web/"}]},{"title":"CSS基础","slug":"css-01","date":"2019-01-18T01:34:36.000Z","updated":"2019-03-07T12:31:13.887Z","comments":true,"path":"css-01.html","link":"","permalink":"https://lesama.github.io/css-01.html","excerpt":"","text":"1. CSS的基本使用行内样式：行内样式可直接写在现有的HTML标签里,比如： 123&lt;p style=\"color:red;font-size:12px;\"&gt;233333333&lt;/p&gt; 内部样式内部样式把CSS样式直接写在当前页面的头部标签中 12345&lt;style type=\"tsxt/css\"&gt; 样式规则：选择器&#123;属性：属性值&#125;&lt;/style&gt; 外部样式外部样式是把CSS样式写在外部CSS文件中，通过嵌在页面的头部标签中 123&lt;link rel=\"stylesheet\" href=\"要引入的网址\"&gt; 2. 选择器基本标签选择器 标签名 类选择器 . ID选择器 # 其他后代 .div span 子代 .div&gt;span 兄弟 .div~span 向下执行相同的 相邻 .div+span 全选择器 * div,span{ } 可以节省重复代码 伪类选择器 link 未访问的 visited 访问后的 hover 划过 active 激活状态的 3. 字体 font属性常见的文本样式：color：字体颜色 font-size：字体大小 font-family：字体类型 &lt;strong&gt;：字体加粗 font-weight：bold 字体加粗 &lt;em&gt; 斜体 font-style：italic斜体 normal（正常） div--层标签 text-decoration：underline(有下划线) none(无下划线)设置下划线 line-through:删除线 text-align：center 文本居中对齐方式 left：对左 right：对右 line-height：行间距 letter-spacing:字符间距 border-radius: px text-indent: 2em首行缩进 Div+css布局方式 height+line-height文字上下居中 test-align：center文字水平居中 背景属性background-color:背景颜色 background-image:url(图片路径); background-repeat:no-repeat;图片不重复 background-repeat:repeat-x(向x轴延伸) background-repeat:repeat-y(向y轴延伸) background-position:图片偏移; dispaly:inline; 转内联 dispaly:block; 转块状 dispaly:inline-block; 转内联块状","categories":[{"name":"web","slug":"web","permalink":"https://lesama.github.io/categories/web/"}],"tags":[{"name":"html","slug":"html","permalink":"https://lesama.github.io/tags/html/"},{"name":"web","slug":"web","permalink":"https://lesama.github.io/tags/web/"},{"name":"网页","slug":"网页","permalink":"https://lesama.github.io/tags/网页/"},{"name":"css","slug":"css","permalink":"https://lesama.github.io/tags/css/"}],"keywords":[{"name":"web","slug":"web","permalink":"https://lesama.github.io/categories/web/"}]},{"title":"HTML介绍及常用标签","slug":"html","date":"2019-01-17T09:39:19.000Z","updated":"2019-02-17T02:55:59.316Z","comments":true,"path":"html.html","link":"","permalink":"https://lesama.github.io/html.html","excerpt":"","text":"1. HTML简介超文本标记语言Hyper(超)Text(文本)MarKup(标记)Language(语言) HTML是一门标记语言，标记语言就是靠标签组成，学习HTML就是学习标签的使用 HTML代码在执行过程中是从上往下执行的 什么是标签 由尖括号包裹单词构成，所以标签不可能以数字开头 不区分大小写，推荐小写 标签可以嵌套，不能交叉嵌套 2. 常用标签初始标签 title:标题标签 head:头部标签 ​body:主体标签 常见标签 h1-h6:文章标题 p:段落标签 span:用来组合文档中的行内元素 strong/b:加粗 i:斜体 s:删除线 块状标签和内联标签(行内标签) 块状：霸道 独占一行，前后自动换 行，可以设置宽高 内联(行内)：在一行直到满了为止换行 列表 有序列表：ol li 无序列表：ul li 定义列表：dl dt dd 图片src = 图片 ../ 相对路径 直接从电脑的是绝对路径 超链接(a标签)123&lt;a href=\" \" target=\" \" title=\" \" &gt; href = 跳转的路径 target 打开方式，默认 self 在本身打开，blank 在新的空白页面打开 title 鼠标下方提示文本 特殊标签 &amp;nbsp 空格 &amp;lt 小于 &amp;gt 大于 &amp;emsp 字符宽 表格(table) table:表格标签 thead:表格头部 tbody:表格主题 tfoot:表格脚部 tr:行 td:列 colspan:合并列 rowspan:合并行 表单(from)123&lt;from action=\" \" method=\" \" &gt; action:提交到的路径 method:提交的方式 ​ 默认值是 get ，会在地址栏显示安全性较差，对于提交的内容有长度限制 ​ post 不会显示在地址栏相对安全，对于提交的内容没有长度限制 input标签 文 本 框: 123&lt;input type=\"text\" value=\"\" maxlength=\"可输入的最大长度\" size=\"\" /&gt; 提交按钮: 123&lt;input type=\"submit\" value=\"提交\" /&gt; 普通按钮: 123&lt;input type=\"button\" value=\"普通按钮\" /&gt; 密 码 框: 123&lt;input type=\"password\" /&gt; 重置按钮: 123&lt;input type=\"reset\" value=\"重置\" /&gt; 单选按钮: 123&lt;input type=\"radio\" /&gt;name必须设置成一样的,表示是一组单选按钮 checked=\"checked\"默认选中 文件上传域: 123&lt;input type=\"file\"/&gt; 多选按钮: 123&lt;input type=\"checkbox\" /&gt;name可以设置成不一样的,要求设置成一样的 下 拉 框: 123&lt;select&gt;&lt;option&gt;&lt;/option&gt;&lt;/select&gt; 多行文本域: 123&lt;textarea rows=\"行\" cols=\"列\"&gt;&lt;/textarea&gt; 隐 藏 域: 123&lt;input type=\"hidden\" /&gt; 图片按钮: 123&lt;input type=\"image\" src= \"\" onmouseover/&gt; 3. 扩展在输入框中输入要搜索的信息，点击”百度一下“则跳转到百度对应的搜索信息，代码如下： 123456&lt;form action=\"https://www.baidu.com/s\" method=\"get\"&gt; 百度搜索 &lt;input type=\"text\" placeholder=\"请输入搜索内容\" name='wd'&gt; &lt;input tpye='submit' name='百度一下'&gt;&lt;/form&gt;","categories":[{"name":"web","slug":"web","permalink":"https://lesama.github.io/categories/web/"}],"tags":[{"name":"html","slug":"html","permalink":"https://lesama.github.io/tags/html/"},{"name":"web","slug":"web","permalink":"https://lesama.github.io/tags/web/"},{"name":"网页","slug":"网页","permalink":"https://lesama.github.io/tags/网页/"}],"keywords":[{"name":"web","slug":"web","permalink":"https://lesama.github.io/categories/web/"}]}]}